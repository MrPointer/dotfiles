# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Essential environment setup
export VISUAL=vim
export EDITOR="$VISUAL"
export LANG="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"

# History configuration
HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000
setopt appendhistory

# Setup some stuff for oh-my-zsh plugins
export ZSH_CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/"
zstyle ':completion:*' menu select
mkdir -p ~/.zfunc &>/dev/null
fpath+=~/.zfunc

# OPTIMIZED: Single compinit call with caching
# Only do expensive compinit if dump is older than 24h or missing
autoload -Uz compinit
if [[ -n ~/.zcompdump(#qN.mh+24) ]]; then
    compinit
else
    compinit -C  # Skip security check for faster loading
fi
autoload -Uz bashcompinit && bashcompinit
autoload -Uz select-word-style
select-word-style bash

# Load brew environment if deferred from zshenv
if [[ -v DEFER_BREW_LOAD && "$DEFER_BREW_LOAD" == "true" ]]; then
  load_brew_env
fi

# Enable homebrew completions (fast fpath addition)
if command -v brew &>/dev/null; then
  FPATH="$BREW_HOME/share/zsh/site-functions:$FPATH"
fi

# Fast aliases (no command execution)
alias gmv="git mv"
if command -v nvim &>/dev/null; then
  alias vi="nvim"
  alias vim="nvim"
fi

# Lazy pyenv shell integration (interactive only)
# - Keep startup fast by avoiding `pyenv init` during shell start.
# - Load `pyenv-virtualenv` integration only when Python tooling is used.
if [[ -o interactive ]] && [[ -d "$HOME/.pyenv" ]]; then
    _pyenv_find_up() {
        local target="$1"
        local dir="$PWD"

        while [[ -n "$dir" && "$dir" != "/" && "$dir" != "$HOME" ]]; do
            [[ -e "$dir/$target" ]] && return 0
            dir="${dir:h}"
        done

        [[ -e "$dir/$target" ]] && return 0
        return 1
    }

    _pyenv_lazy_init() {
        # Guard against re-entrancy.
        if [[ -n "${_PYENV_LAZY_INIT_DONE:-}" ]]; then
            return 0
        fi
        _PYENV_LAZY_INIT_DONE=1

        # Load full shell integration.
        # Use `command` to ensure we call the pyenv binary (not a shell function).
        eval "$(command pyenv init - zsh)"
        eval "$(command pyenv virtualenv-init - zsh)"

        # Remove hook + helpers to keep runtime overhead at ~0.
        autoload -U add-zsh-hook
        add-zsh-hook -d preexec _pyenv_lazy_preexec
        typeset -ga precmd_functions
        precmd_functions=(${precmd_functions:#_pyenv_lazy_precmd})
        unfunction _pyenv_lazy_precmd _pyenv_lazy_preexec _pyenv_lazy_init _pyenv_find_up 2>/dev/null
    }

    _pyenv_lazy_precmd() {
        # Initialize before the first prompt if the current directory (or an ancestor)
        # indicates that pyenv integration is needed.
        #
        # - `.python-version` enables pyenv local versions / pyenv-virtualenv activation.
        # - `.envrc` is a common driver via direnv (`use pyenv ...`), which would otherwise
        #   call `pyenv shell` without shell integration and print warnings.
        if _pyenv_find_up ".python-version" || _pyenv_find_up ".envrc"; then
            _pyenv_lazy_init
        fi
    }

    _pyenv_lazy_preexec() {
        # Only trigger on commands that plausibly need Python/pyenv.
        local cmd="$1"
        case "$cmd" in
            pyenv*|python*|pip*|poetry*|pipx*|pytest*|tox*|uv*|ruff*|mypy*)
                _pyenv_lazy_init
                ;;
        esac
    }

    autoload -U add-zsh-hook
    typeset -ga precmd_functions
    if (( ${precmd_functions[(I)_pyenv_lazy_precmd]} == 0 )); then
        precmd_functions=(_pyenv_lazy_precmd $precmd_functions)
    fi
    add-zsh-hook preexec _pyenv_lazy_preexec
fi

# Fast PATH additions (no expensive operations)
if command -v cargo &>/dev/null; then
    export PATH="$PATH:$HOME/.cargo/bin"
fi

if command -v go &>/dev/null; then
    export PATH="$PATH:$HOME/go/bin"
fi

if [[ -d "$BREW_HOME/lib/ruby" ]]; then
    export PATH="$PATH:$BREW_HOME/lib/ruby/gems/3.1.0/bin"
fi

if [[ -d "$BREW_HOME/opt/clang-format" ]]; then
    export PATH="$BREW_HOME/opt/clang-format/bin:$PATH"
fi

if command -v bun &>/dev/null; then
    export PATH="$HOME/.bun/bin:$PATH"
fi

# COMPLETION CACHING: Generate completion functions synchronously but only when needed
# Cache directory for completions
local comp_cache_dir="$HOME/.cache/zsh-completions"
mkdir -p "$comp_cache_dir"

# Fast completion setup - only generate if missing or old
[[ -x "$(command -v rustup)" && ( ! -f "$HOME/.zfunc/_cargo" || -n "$(find "$HOME/.zfunc/_cargo" -mtime +7 2>/dev/null)" ) ]] && rustup completions zsh cargo > "$HOME/.zfunc/_cargo" 2>/dev/null

[[ -x "$(command -v poetry)" && ( ! -f "$HOME/.zfunc/_poetry" || -n "$(find "$HOME/.zfunc/_poetry" -mtime +7 2>/dev/null)" ) ]] && poetry completions zsh > "$HOME/.zfunc/_poetry" 2>/dev/null

[[ -x "$(command -v chezmoi)" && ( ! -f "$HOME/.zfunc/_chezmoi" || -n "$(find "$HOME/.zfunc/_chezmoi" -mtime +7 2>/dev/null)" ) ]] && chezmoi completion zsh > "$HOME/.zfunc/_chezmoi" 2>/dev/null

[[ -x "$(command -v npm)" && ( ! -f "$HOME/.zfunc/_npm" || -n "$(find "$HOME/.zfunc/_npm" -mtime +7 2>/dev/null)" ) ]] && npm completion > "$HOME/.zfunc/_npm" 2>/dev/null

[[ -x "$(command -v pip)" && ( ! -f "$HOME/.zfunc/_pip" || -n "$(find "$HOME/.zfunc/_pip" -mtime +7 2>/dev/null)" ) ]] && pip completion --zsh > "$HOME/.zfunc/_pip" 2>/dev/null

# Load dotnet completions if available
if command -v dotnet &>/dev/null; then
  [[ -f ~/.zfunc/_dotnet ]] && . ~/.zfunc/_dotnet
fi

# DEFERRED ENVIRONMENT SETUP: Tools that need runtime evaluation (non-cacheable)
# =============================================================================
# These tools require environment setup or runtime evaluation that cannot be cached.
# NOTE: pipx and az completions moved to after sheldon loads (need zsh-defer)

# Other environment variables (fast)
if command -v jfrog &>/dev/null; then
  export JFROG_CLI_AVOID_NEW_VERSION_WARNING=false
fi

# Setup custom aliases
{{ if (hasKey .personal "signing_key") -}}
alias gpg-unlock='gpg --sign --local-user {{ .personal.signing_key }} --output /dev/null /dev/null'
{{- end }}

{{ if .personal.work_env -}}
[[ -f "$WORK_ZSH_RC_EXTENSION" ]] && source "$WORK_ZSH_RC_EXTENSION"
{{- end }}

# Load custom functions and plugins (fast local file operations)
function load_zsh_function {
  local func_name="$1"
  local func_path="$HOME/.local/share/zsh/functions/${func_name}.zsh"
  [[ -f "${func_path}" ]] && source "${func_path}"
}

function load_custom_plugin {
  local plugin_name="$1"
  local plugin_path="$HOME/.local/share/zsh/plugins/${plugin_name}"
  [[ -d "${plugin_path}" ]] && source "${plugin_path}/${plugin_name}.plugin.zsh"
}

# Load some oh-my-zsh functions
load_zsh_function "git"

# Load some oh-my-zsh plugins
load_custom_plugin "key-bindings"
load_custom_plugin "git"
load_custom_plugin "dotenv"

# Clean up namespace
unfunction load_custom_plugin load_zsh_function

# Ensure zsh recognizes common Home/End sequences from any terminal emulator:
bindkey '\e[H'  beginning-of-line   # ESC [ H
bindkey '\e[1~' beginning-of-line   # ESC [ 1 ~
bindkey '\eOH'  beginning-of-line   # ESC O H (application mode)

bindkey '\e[F'  end-of-line         # ESC [ F
bindkey '\e[4~' end-of-line         # ESC [ 4 ~
bindkey '\eOF'  end-of-line         # ESC O F (application mode)

# Additional mappings to match Rio macOS keybindings (matched to ZLE widgets):
# - Cmd+Backspace -> ESC [ U  -> delete from cursor to beginning of line
# - Cmd+Delete    -> ESC [ K  -> delete from cursor to end of line
# - Option+Delete -> ESC d    -> delete/kill next word
# - PageUp/PageDown -> ESC [ 5 ~ / ESC [ 6 ~ -> history navigation

# Delete from cursor to beginning of line
bindkey '\e[U' backward-kill-line   # ESC [ U

# Delete from cursor to end of line
bindkey '\e[K' kill-line            # ESC [ K

# Option+Delete (Alt+Delete) => kill next word
bindkey '\ed' kill-word             # ESC d

# Load plugins with sheldon (The list of plugins is in ~/.config/sheldon/plugins.toml)
eval "$(sheldon source)"

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# DEFERRED LOADING: Now that zsh-defer is available, load heavy tools in background
# =============================================================================

# Load NVM with deferral to avoid blocking startup
if [[ -f "$BREW_HOME/opt/nvm/nvm.sh" ]]; then
    zsh-defer source "$BREW_HOME/opt/nvm/nvm.sh"
    zsh-defer -c 'autoload -U add-zsh-hook; add-zsh-hook chpwd nvm_auto_use; nvm_auto_use'
fi

# Deferred completion setup for tools requiring runtime evaluation
if command -v pipx &>/dev/null; then
  # pipx uses Python argcomplete which needs runtime environment setup
  # Avoid printing shim/argcomplete errors during startup.
  zsh-defer -c 'eval "$(register-python-argcomplete pipx 2>/dev/null)"'
fi

if command -v az &>/dev/null; then
  # Azure CLI uses existing bash completion files
  zsh-defer source "$(brew --prefix)/etc/bash_completion.d/az"
fi

# Task completion requires eval (not file caching) because it generates executable code
if command -v task &>/dev/null; then
  # Register go-task completions - deferred to ensure compinit is complete
  zsh-defer eval "$(task --completion zsh)"
fi

# Configure fzf stuff, including fzf-tab
local fzf_path
fzf_path="$(command -v fzf)"
if [[ -n "$fzf_path" ]]; then
  if [[ ! -f ~/.fzf.zsh ]]; then
    # fzf completions are missing, generate them
    if [[ "$fzf_path" =~ brew ]]; then
      # fzf is installed with brew
      "$BREW_HOME/opt/fzf/install"
    fi
  fi

  if command -v fd &>/dev/null; then
    export FZF_DEFAULT_COMMAND="fd -t f -t d --color=never --hidden --follow --exclude .git"
  fi

  export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
  # Use pre-generated .fzf.zsh instead of dynamic command substitution
  [[ -f ~/.fzf.zsh ]] && source ~/.fzf.zsh
fi
unset fzf_path

# FZF configuration

# disable sort when completing `git checkout`
zstyle ':completion:*:git-checkout:*' sort false
# set descriptions format to enable group support
# NOTE: don't use escape sequences (like '%F{red}%d%f') here, fzf-tab will ignore them
zstyle ':completion:*:descriptions' format '[%d]'
# set list-colors to enable filename colorizing
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# force zsh not to show completion menu, which allows fzf-tab to capture the unambiguous prefix
zstyle ':completion:*' menu no
# preview directory's content with eza when completing cd
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1 --color=always $realpath'
# custom fzf flags
# NOTE: fzf-tab does not follow FZF_DEFAULT_OPTS by default
zstyle ':fzf-tab:*' fzf-flags --color=fg:1,fg+:2 --bind=tab:accept
# To make fzf-tab follow FZF_DEFAULT_OPTS.
# NOTE: This may lead to unexpected behavior since some flags break this plugin. See Aloxaf/fzf-tab#455.
zstyle ':fzf-tab:*' use-fzf-default-opts yes
# switch group using `<` and `>`
zstyle ':fzf-tab:*' switch-group '<' '>'
# Disable continuous completion
zstyle ':fzf-tab:*' continuous-trigger ''

# Enable rich shell integration for VSCode
if [[ "$TERM_PROGRAM" == "vscode" ]]; then
  # Disable suggestions (for now)
  export VSCODE_SUGGEST=0
  {{ if (eq .chezmoi.os "darwin") -}}
  local vscode_script="/Applications/Visual Studio Code.app/Contents/Resources/app/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration-rc.zsh"
  [[ -f "$vscode_script" ]] && source "$vscode_script"
  {{- else -}}
  if command -v code &>/dev/null; then
    local integration_path="$(code --locate-shell-integration-path zsh 2>/dev/null)"
    [[ -f "$integration_path" ]] && source "$integration_path"
  fi
  {{- end }}
fi

# NVM setup with background loading to avoid blocking startup
function nvm_auto_use() {
    # Only run if nvm is loaded
    local node_version="$(nvm version 2>/dev/null)"
    local nvmrc_path="$(nvm_find_nvmrc 2>/dev/null)"

    if [[ -n "$nvmrc_path" ]]; then
       local nvmrc_node_version="$(nvm version "$(cat "${nvmrc_path}")" 2>/dev/null)"

       if [[ "$nvmrc_node_version" = "N/A" ]]; then
             nvm install
       elif [[ "$nvmrc_node_version" != "$node_version" ]]; then
             nvm use
       fi
    elif [[ "$node_version" != "$(nvm version default 2>/dev/null)" ]]; then
       echo "Reverting to nvm default version"
       nvm use default 2>/dev/null
    fi
}
