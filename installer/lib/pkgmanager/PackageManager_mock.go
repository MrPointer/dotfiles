// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package pkgmanager

import (
	"sync"
)

// Ensure that MoqPackageManager does implement PackageManager.
// If this is not the case, regenerate this file with mockery.
var _ PackageManager = &MoqPackageManager{}

// MoqPackageManager is a mock implementation of PackageManager.
//
//	func TestSomethingThatUsesPackageManager(t *testing.T) {
//
//		// make and configure a mocked PackageManager
//		mockedPackageManager := &MoqPackageManager{
//			GetInfoFunc: func() (PackageManagerInfo, error) {
//				panic("mock out the GetInfo method")
//			},
//			GetPackageVersionFunc: func(packageName string) (string, error) {
//				panic("mock out the GetPackageVersion method")
//			},
//			InstallPackageFunc: func(requestedPackageInfo RequestedPackageInfo) error {
//				panic("mock out the InstallPackage method")
//			},
//			IsPackageInstalledFunc: func(packageInfo PackageInfo) (bool, error) {
//				panic("mock out the IsPackageInstalled method")
//			},
//			ListInstalledPackagesFunc: func() ([]PackageInfo, error) {
//				panic("mock out the ListInstalledPackages method")
//			},
//			UninstallPackageFunc: func(packageInfo PackageInfo) error {
//				panic("mock out the UninstallPackage method")
//			},
//		}
//
//		// use mockedPackageManager in code that requires PackageManager
//		// and then make assertions.
//
//	}
type MoqPackageManager struct {
	// GetInfoFunc mocks the GetInfo method.
	GetInfoFunc func() (PackageManagerInfo, error)

	// GetPackageVersionFunc mocks the GetPackageVersion method.
	GetPackageVersionFunc func(packageName string) (string, error)

	// InstallPackageFunc mocks the InstallPackage method.
	InstallPackageFunc func(requestedPackageInfo RequestedPackageInfo) error

	// IsPackageInstalledFunc mocks the IsPackageInstalled method.
	IsPackageInstalledFunc func(packageInfo PackageInfo) (bool, error)

	// ListInstalledPackagesFunc mocks the ListInstalledPackages method.
	ListInstalledPackagesFunc func() ([]PackageInfo, error)

	// UninstallPackageFunc mocks the UninstallPackage method.
	UninstallPackageFunc func(packageInfo PackageInfo) error

	// calls tracks calls to the methods.
	calls struct {
		// GetInfo holds details about calls to the GetInfo method.
		GetInfo []struct {
		}
		// GetPackageVersion holds details about calls to the GetPackageVersion method.
		GetPackageVersion []struct {
			// PackageName is the packageName argument value.
			PackageName string
		}
		// InstallPackage holds details about calls to the InstallPackage method.
		InstallPackage []struct {
			// RequestedPackageInfo is the requestedPackageInfo argument value.
			RequestedPackageInfo RequestedPackageInfo
		}
		// IsPackageInstalled holds details about calls to the IsPackageInstalled method.
		IsPackageInstalled []struct {
			// PackageInfo is the packageInfo argument value.
			PackageInfo PackageInfo
		}
		// ListInstalledPackages holds details about calls to the ListInstalledPackages method.
		ListInstalledPackages []struct {
		}
		// UninstallPackage holds details about calls to the UninstallPackage method.
		UninstallPackage []struct {
			// PackageInfo is the packageInfo argument value.
			PackageInfo PackageInfo
		}
	}
	lockGetInfo               sync.RWMutex
	lockGetPackageVersion     sync.RWMutex
	lockInstallPackage        sync.RWMutex
	lockIsPackageInstalled    sync.RWMutex
	lockListInstalledPackages sync.RWMutex
	lockUninstallPackage      sync.RWMutex
}

// GetInfo calls GetInfoFunc.
func (mock *MoqPackageManager) GetInfo() (PackageManagerInfo, error) {
	if mock.GetInfoFunc == nil {
		panic("MoqPackageManager.GetInfoFunc: method is nil but PackageManager.GetInfo was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetInfo.Lock()
	mock.calls.GetInfo = append(mock.calls.GetInfo, callInfo)
	mock.lockGetInfo.Unlock()
	return mock.GetInfoFunc()
}

// GetInfoCalls gets all the calls that were made to GetInfo.
// Check the length with:
//
//	len(mockedPackageManager.GetInfoCalls())
func (mock *MoqPackageManager) GetInfoCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetInfo.RLock()
	calls = mock.calls.GetInfo
	mock.lockGetInfo.RUnlock()
	return calls
}

// GetPackageVersion calls GetPackageVersionFunc.
func (mock *MoqPackageManager) GetPackageVersion(packageName string) (string, error) {
	if mock.GetPackageVersionFunc == nil {
		panic("MoqPackageManager.GetPackageVersionFunc: method is nil but PackageManager.GetPackageVersion was just called")
	}
	callInfo := struct {
		PackageName string
	}{
		PackageName: packageName,
	}
	mock.lockGetPackageVersion.Lock()
	mock.calls.GetPackageVersion = append(mock.calls.GetPackageVersion, callInfo)
	mock.lockGetPackageVersion.Unlock()
	return mock.GetPackageVersionFunc(packageName)
}

// GetPackageVersionCalls gets all the calls that were made to GetPackageVersion.
// Check the length with:
//
//	len(mockedPackageManager.GetPackageVersionCalls())
func (mock *MoqPackageManager) GetPackageVersionCalls() []struct {
	PackageName string
} {
	var calls []struct {
		PackageName string
	}
	mock.lockGetPackageVersion.RLock()
	calls = mock.calls.GetPackageVersion
	mock.lockGetPackageVersion.RUnlock()
	return calls
}

// InstallPackage calls InstallPackageFunc.
func (mock *MoqPackageManager) InstallPackage(requestedPackageInfo RequestedPackageInfo) error {
	if mock.InstallPackageFunc == nil {
		panic("MoqPackageManager.InstallPackageFunc: method is nil but PackageManager.InstallPackage was just called")
	}
	callInfo := struct {
		RequestedPackageInfo RequestedPackageInfo
	}{
		RequestedPackageInfo: requestedPackageInfo,
	}
	mock.lockInstallPackage.Lock()
	mock.calls.InstallPackage = append(mock.calls.InstallPackage, callInfo)
	mock.lockInstallPackage.Unlock()
	return mock.InstallPackageFunc(requestedPackageInfo)
}

// InstallPackageCalls gets all the calls that were made to InstallPackage.
// Check the length with:
//
//	len(mockedPackageManager.InstallPackageCalls())
func (mock *MoqPackageManager) InstallPackageCalls() []struct {
	RequestedPackageInfo RequestedPackageInfo
} {
	var calls []struct {
		RequestedPackageInfo RequestedPackageInfo
	}
	mock.lockInstallPackage.RLock()
	calls = mock.calls.InstallPackage
	mock.lockInstallPackage.RUnlock()
	return calls
}

// IsPackageInstalled calls IsPackageInstalledFunc.
func (mock *MoqPackageManager) IsPackageInstalled(packageInfo PackageInfo) (bool, error) {
	if mock.IsPackageInstalledFunc == nil {
		panic("MoqPackageManager.IsPackageInstalledFunc: method is nil but PackageManager.IsPackageInstalled was just called")
	}
	callInfo := struct {
		PackageInfo PackageInfo
	}{
		PackageInfo: packageInfo,
	}
	mock.lockIsPackageInstalled.Lock()
	mock.calls.IsPackageInstalled = append(mock.calls.IsPackageInstalled, callInfo)
	mock.lockIsPackageInstalled.Unlock()
	return mock.IsPackageInstalledFunc(packageInfo)
}

// IsPackageInstalledCalls gets all the calls that were made to IsPackageInstalled.
// Check the length with:
//
//	len(mockedPackageManager.IsPackageInstalledCalls())
func (mock *MoqPackageManager) IsPackageInstalledCalls() []struct {
	PackageInfo PackageInfo
} {
	var calls []struct {
		PackageInfo PackageInfo
	}
	mock.lockIsPackageInstalled.RLock()
	calls = mock.calls.IsPackageInstalled
	mock.lockIsPackageInstalled.RUnlock()
	return calls
}

// ListInstalledPackages calls ListInstalledPackagesFunc.
func (mock *MoqPackageManager) ListInstalledPackages() ([]PackageInfo, error) {
	if mock.ListInstalledPackagesFunc == nil {
		panic("MoqPackageManager.ListInstalledPackagesFunc: method is nil but PackageManager.ListInstalledPackages was just called")
	}
	callInfo := struct {
	}{}
	mock.lockListInstalledPackages.Lock()
	mock.calls.ListInstalledPackages = append(mock.calls.ListInstalledPackages, callInfo)
	mock.lockListInstalledPackages.Unlock()
	return mock.ListInstalledPackagesFunc()
}

// ListInstalledPackagesCalls gets all the calls that were made to ListInstalledPackages.
// Check the length with:
//
//	len(mockedPackageManager.ListInstalledPackagesCalls())
func (mock *MoqPackageManager) ListInstalledPackagesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockListInstalledPackages.RLock()
	calls = mock.calls.ListInstalledPackages
	mock.lockListInstalledPackages.RUnlock()
	return calls
}

// UninstallPackage calls UninstallPackageFunc.
func (mock *MoqPackageManager) UninstallPackage(packageInfo PackageInfo) error {
	if mock.UninstallPackageFunc == nil {
		panic("MoqPackageManager.UninstallPackageFunc: method is nil but PackageManager.UninstallPackage was just called")
	}
	callInfo := struct {
		PackageInfo PackageInfo
	}{
		PackageInfo: packageInfo,
	}
	mock.lockUninstallPackage.Lock()
	mock.calls.UninstallPackage = append(mock.calls.UninstallPackage, callInfo)
	mock.lockUninstallPackage.Unlock()
	return mock.UninstallPackageFunc(packageInfo)
}

// UninstallPackageCalls gets all the calls that were made to UninstallPackage.
// Check the length with:
//
//	len(mockedPackageManager.UninstallPackageCalls())
func (mock *MoqPackageManager) UninstallPackageCalls() []struct {
	PackageInfo PackageInfo
} {
	var calls []struct {
		PackageInfo PackageInfo
	}
	mock.lockUninstallPackage.RLock()
	calls = mock.calls.UninstallPackage
	mock.lockUninstallPackage.RUnlock()
	return calls
}
