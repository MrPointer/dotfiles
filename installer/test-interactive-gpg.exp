#!/usr/bin/expect -f
#
# Interactive GPG Testing Script for Dotfiles Installer
# Usage: ./test-interactive-gpg.exp [installer_path] [email] [name] [passphrase]
#
# This script automates GPG key setup during interactive installation
# for both CI testing and local development.

# Set default timeout (in seconds)
set timeout 300

# Parse command line arguments with defaults
set installer_path [lindex $argv 0]
set email [lindex $argv 1]
set name [lindex $argv 2]
set passphrase [lindex $argv 3]
set verbosity [lindex $argv 4]

# Use defaults if not provided
if {$installer_path eq ""} {
    set installer_path "./dotfiles-installer"
}
if {$email eq ""} {
    set email "test-user@example.com"
}
if {$name eq ""} {
    set name "Test CI User"
}
if {$passphrase eq ""} {
    set passphrase "test-ci-passphrase"
}
if {$verbosity eq ""} {
    set verbosity ""
}

# Enable debugging output (set to 1 for verbose debugging)
exp_internal 0

# Log all output to help debug unmatched prompts
log_user 1

# Start the installer
puts "ğŸ”‘ Starting interactive GPG test with:"
puts "  Installer: $installer_path"
puts "  Email: $email"
puts "  Name: $name"
puts "  Passphrase: [string repeat "*" [string length $passphrase]]"
puts "  Verbosity: $verbosity"
puts ""

spawn $installer_path install --plain --install-prerequisites=true --git-clone-protocol=https "$verbosity"

# Main interaction loop - Only handle GPG-specific prompts
expect {
    # GPG email prompts (various possible formats)
    -re "(?i).*(email|e-?mail address)" {
        puts "ğŸ“§ Entering email address..."
        send "$email\r"
        exp_continue
    }

    # GPG name/full name prompts
    -re "(?i).*(full name|name|real name)" {
        puts "ğŸ‘¤ Entering full name..."
        send "$name\r"
        exp_continue
    }

    # GPG passphrase prompts
    -re "(?i).*(passphrase|password)" {
        puts "ğŸ” Entering passphrase..."
        send "$passphrase\r"
        exp_continue
    }

    # GPG "okay" confirmation - exact match for the problematic prompt
    -re "Change.*Name.*Email.*kay.*uit" {
        puts "âœ… GPG change/okay prompt (sending O)..."
        send "O\r"
        exp_continue
    }

    # GPG "okay" confirmation - matches "(O)kay" pattern
    -re "\\(O\\)kay" {
        puts "âœ… GPG okay confirmation (sending O)..."
        send "O\r"
        exp_continue
    }

    # Fallback: any prompt containing "(O)" - likely GPG menu
    -re "\\(O\\)" {
        puts "âœ… GPG menu with O option (sending O)..."
        send "O\r"
        exp_continue
    }

    # GPG key generation prompts
    -re "(?i).*(key.*size|rsa.*bits)" {
        puts "ğŸ”§ Using default key size..."
        send "\r"
        exp_continue
    }

    # Key expiration prompts
    -re "(?i).*(key.*expir|expir.*date)" {
        puts "â° Setting key expiration..."
        send "0\r"
        exp_continue
    }

    # GPG key type selection (default to RSA)
    -re "(?i).*(kind of key|key.*type)" {
        puts "ğŸ”‘ Selecting default key type..."
        send "\r"
        exp_continue
    }

    # GPG comment field (usually optional)
    -re "(?i).*comment" {
        puts "ğŸ’¬ Skipping comment field..."
        send "\r"
        exp_continue
    }

    # Error patterns
    -re "(?i).*(error|fail|abort)" {
        puts "âŒ Error detected in output"
        set error_output $expect_out(buffer)
        puts "Error details: $error_output"
        # Don't exit immediately - some errors might be expected in CI
        exp_continue
    }

    # Success patterns
    -re "(?i).*(success|complete|finished|done)" {
        puts "âœ… Installation appears to have completed successfully"
        exp_continue
    }

    # Timeout handling
    timeout {
        puts "â° Timeout reached after 300 seconds"
        exit 1
    }

    # End of output
    eof {
        puts "ğŸ“‹ Process completed"
        # Get exit status
        catch wait result
        set exit_code [lindex $result 3]
        puts "Exit code: $exit_code"

        if {$exit_code == 0} {
            puts "âœ… Installation completed successfully!"
            exit 0
        } else {
            puts "âŒ Installation failed with exit code: $exit_code"
            exit $exit_code
        }
    }
}

# This should never be reached, but just in case
puts "ğŸ¤” Unexpected end of script"
exit 0
