// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package utils

import (
	"io"
	"sync"
)

// Ensure that MoqFileSystem does implement FileSystem.
// If this is not the case, regenerate this file with mockery.
var _ FileSystem = &MoqFileSystem{}

// MoqFileSystem is a mock implementation of FileSystem.
//
//	func TestSomethingThatUsesFileSystem(t *testing.T) {
//
//		// make and configure a mocked FileSystem
//		mockedFileSystem := &MoqFileSystem{
//			CreateDirectoryFunc: func(path string) error {
//				panic("mock out the CreateDirectory method")
//			},
//			CreateFileFunc: func(path string) (string, error) {
//				panic("mock out the CreateFile method")
//			},
//			CreateTemporaryDirectoryFunc: func(dir string) (string, error) {
//				panic("mock out the CreateTemporaryDirectory method")
//			},
//			CreateTemporaryFileFunc: func(dir string, pattern string) (string, error) {
//				panic("mock out the CreateTemporaryFile method")
//			},
//			PathExistsFunc: func(path string) (bool, error) {
//				panic("mock out the PathExists method")
//			},
//			ReadFileFunc: func(path string, receiver io.Writer) (int64, error) {
//				panic("mock out the ReadFile method")
//			},
//			RemovePathFunc: func(path string) error {
//				panic("mock out the RemovePath method")
//			},
//			WriteFileFunc: func(path string, reader io.Reader) (int64, error) {
//				panic("mock out the WriteFile method")
//			},
//		}
//
//		// use mockedFileSystem in code that requires FileSystem
//		// and then make assertions.
//
//	}
type MoqFileSystem struct {
	// CreateDirectoryFunc mocks the CreateDirectory method.
	CreateDirectoryFunc func(path string) error

	// CreateFileFunc mocks the CreateFile method.
	CreateFileFunc func(path string) (string, error)

	// CreateTemporaryDirectoryFunc mocks the CreateTemporaryDirectory method.
	CreateTemporaryDirectoryFunc func(dir string) (string, error)

	// CreateTemporaryFileFunc mocks the CreateTemporaryFile method.
	CreateTemporaryFileFunc func(dir string, pattern string) (string, error)

	// PathExistsFunc mocks the PathExists method.
	PathExistsFunc func(path string) (bool, error)

	// ReadFileFunc mocks the ReadFile method.
	ReadFileFunc func(path string, receiver io.Writer) (int64, error)

	// RemovePathFunc mocks the RemovePath method.
	RemovePathFunc func(path string) error

	// WriteFileFunc mocks the WriteFile method.
	WriteFileFunc func(path string, reader io.Reader) (int64, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateDirectory holds details about calls to the CreateDirectory method.
		CreateDirectory []struct {
			// Path is the path argument value.
			Path string
		}
		// CreateFile holds details about calls to the CreateFile method.
		CreateFile []struct {
			// Path is the path argument value.
			Path string
		}
		// CreateTemporaryDirectory holds details about calls to the CreateTemporaryDirectory method.
		CreateTemporaryDirectory []struct {
			// Dir is the dir argument value.
			Dir string
		}
		// CreateTemporaryFile holds details about calls to the CreateTemporaryFile method.
		CreateTemporaryFile []struct {
			// Dir is the dir argument value.
			Dir string
			// Pattern is the pattern argument value.
			Pattern string
		}
		// PathExists holds details about calls to the PathExists method.
		PathExists []struct {
			// Path is the path argument value.
			Path string
		}
		// ReadFile holds details about calls to the ReadFile method.
		ReadFile []struct {
			// Path is the path argument value.
			Path string
			// Receiver is the receiver argument value.
			Receiver io.Writer
		}
		// RemovePath holds details about calls to the RemovePath method.
		RemovePath []struct {
			// Path is the path argument value.
			Path string
		}
		// WriteFile holds details about calls to the WriteFile method.
		WriteFile []struct {
			// Path is the path argument value.
			Path string
			// Reader is the reader argument value.
			Reader io.Reader
		}
	}
	lockCreateDirectory          sync.RWMutex
	lockCreateFile               sync.RWMutex
	lockCreateTemporaryDirectory sync.RWMutex
	lockCreateTemporaryFile      sync.RWMutex
	lockPathExists               sync.RWMutex
	lockReadFile                 sync.RWMutex
	lockRemovePath               sync.RWMutex
	lockWriteFile                sync.RWMutex
}

// CreateDirectory calls CreateDirectoryFunc.
func (mock *MoqFileSystem) CreateDirectory(path string) error {
	if mock.CreateDirectoryFunc == nil {
		panic("MoqFileSystem.CreateDirectoryFunc: method is nil but FileSystem.CreateDirectory was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockCreateDirectory.Lock()
	mock.calls.CreateDirectory = append(mock.calls.CreateDirectory, callInfo)
	mock.lockCreateDirectory.Unlock()
	return mock.CreateDirectoryFunc(path)
}

// CreateDirectoryCalls gets all the calls that were made to CreateDirectory.
// Check the length with:
//
//	len(mockedFileSystem.CreateDirectoryCalls())
func (mock *MoqFileSystem) CreateDirectoryCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockCreateDirectory.RLock()
	calls = mock.calls.CreateDirectory
	mock.lockCreateDirectory.RUnlock()
	return calls
}

// CreateFile calls CreateFileFunc.
func (mock *MoqFileSystem) CreateFile(path string) (string, error) {
	if mock.CreateFileFunc == nil {
		panic("MoqFileSystem.CreateFileFunc: method is nil but FileSystem.CreateFile was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockCreateFile.Lock()
	mock.calls.CreateFile = append(mock.calls.CreateFile, callInfo)
	mock.lockCreateFile.Unlock()
	return mock.CreateFileFunc(path)
}

// CreateFileCalls gets all the calls that were made to CreateFile.
// Check the length with:
//
//	len(mockedFileSystem.CreateFileCalls())
func (mock *MoqFileSystem) CreateFileCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockCreateFile.RLock()
	calls = mock.calls.CreateFile
	mock.lockCreateFile.RUnlock()
	return calls
}

// CreateTemporaryDirectory calls CreateTemporaryDirectoryFunc.
func (mock *MoqFileSystem) CreateTemporaryDirectory(dir string) (string, error) {
	if mock.CreateTemporaryDirectoryFunc == nil {
		panic("MoqFileSystem.CreateTemporaryDirectoryFunc: method is nil but FileSystem.CreateTemporaryDirectory was just called")
	}
	callInfo := struct {
		Dir string
	}{
		Dir: dir,
	}
	mock.lockCreateTemporaryDirectory.Lock()
	mock.calls.CreateTemporaryDirectory = append(mock.calls.CreateTemporaryDirectory, callInfo)
	mock.lockCreateTemporaryDirectory.Unlock()
	return mock.CreateTemporaryDirectoryFunc(dir)
}

// CreateTemporaryDirectoryCalls gets all the calls that were made to CreateTemporaryDirectory.
// Check the length with:
//
//	len(mockedFileSystem.CreateTemporaryDirectoryCalls())
func (mock *MoqFileSystem) CreateTemporaryDirectoryCalls() []struct {
	Dir string
} {
	var calls []struct {
		Dir string
	}
	mock.lockCreateTemporaryDirectory.RLock()
	calls = mock.calls.CreateTemporaryDirectory
	mock.lockCreateTemporaryDirectory.RUnlock()
	return calls
}

// CreateTemporaryFile calls CreateTemporaryFileFunc.
func (mock *MoqFileSystem) CreateTemporaryFile(dir string, pattern string) (string, error) {
	if mock.CreateTemporaryFileFunc == nil {
		panic("MoqFileSystem.CreateTemporaryFileFunc: method is nil but FileSystem.CreateTemporaryFile was just called")
	}
	callInfo := struct {
		Dir     string
		Pattern string
	}{
		Dir:     dir,
		Pattern: pattern,
	}
	mock.lockCreateTemporaryFile.Lock()
	mock.calls.CreateTemporaryFile = append(mock.calls.CreateTemporaryFile, callInfo)
	mock.lockCreateTemporaryFile.Unlock()
	return mock.CreateTemporaryFileFunc(dir, pattern)
}

// CreateTemporaryFileCalls gets all the calls that were made to CreateTemporaryFile.
// Check the length with:
//
//	len(mockedFileSystem.CreateTemporaryFileCalls())
func (mock *MoqFileSystem) CreateTemporaryFileCalls() []struct {
	Dir     string
	Pattern string
} {
	var calls []struct {
		Dir     string
		Pattern string
	}
	mock.lockCreateTemporaryFile.RLock()
	calls = mock.calls.CreateTemporaryFile
	mock.lockCreateTemporaryFile.RUnlock()
	return calls
}

// PathExists calls PathExistsFunc.
func (mock *MoqFileSystem) PathExists(path string) (bool, error) {
	if mock.PathExistsFunc == nil {
		panic("MoqFileSystem.PathExistsFunc: method is nil but FileSystem.PathExists was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockPathExists.Lock()
	mock.calls.PathExists = append(mock.calls.PathExists, callInfo)
	mock.lockPathExists.Unlock()
	return mock.PathExistsFunc(path)
}

// PathExistsCalls gets all the calls that were made to PathExists.
// Check the length with:
//
//	len(mockedFileSystem.PathExistsCalls())
func (mock *MoqFileSystem) PathExistsCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockPathExists.RLock()
	calls = mock.calls.PathExists
	mock.lockPathExists.RUnlock()
	return calls
}

// ReadFile calls ReadFileFunc.
func (mock *MoqFileSystem) ReadFile(path string, receiver io.Writer) (int64, error) {
	if mock.ReadFileFunc == nil {
		panic("MoqFileSystem.ReadFileFunc: method is nil but FileSystem.ReadFile was just called")
	}
	callInfo := struct {
		Path     string
		Receiver io.Writer
	}{
		Path:     path,
		Receiver: receiver,
	}
	mock.lockReadFile.Lock()
	mock.calls.ReadFile = append(mock.calls.ReadFile, callInfo)
	mock.lockReadFile.Unlock()
	return mock.ReadFileFunc(path, receiver)
}

// ReadFileCalls gets all the calls that were made to ReadFile.
// Check the length with:
//
//	len(mockedFileSystem.ReadFileCalls())
func (mock *MoqFileSystem) ReadFileCalls() []struct {
	Path     string
	Receiver io.Writer
} {
	var calls []struct {
		Path     string
		Receiver io.Writer
	}
	mock.lockReadFile.RLock()
	calls = mock.calls.ReadFile
	mock.lockReadFile.RUnlock()
	return calls
}

// RemovePath calls RemovePathFunc.
func (mock *MoqFileSystem) RemovePath(path string) error {
	if mock.RemovePathFunc == nil {
		panic("MoqFileSystem.RemovePathFunc: method is nil but FileSystem.RemovePath was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockRemovePath.Lock()
	mock.calls.RemovePath = append(mock.calls.RemovePath, callInfo)
	mock.lockRemovePath.Unlock()
	return mock.RemovePathFunc(path)
}

// RemovePathCalls gets all the calls that were made to RemovePath.
// Check the length with:
//
//	len(mockedFileSystem.RemovePathCalls())
func (mock *MoqFileSystem) RemovePathCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockRemovePath.RLock()
	calls = mock.calls.RemovePath
	mock.lockRemovePath.RUnlock()
	return calls
}

// WriteFile calls WriteFileFunc.
func (mock *MoqFileSystem) WriteFile(path string, reader io.Reader) (int64, error) {
	if mock.WriteFileFunc == nil {
		panic("MoqFileSystem.WriteFileFunc: method is nil but FileSystem.WriteFile was just called")
	}
	callInfo := struct {
		Path   string
		Reader io.Reader
	}{
		Path:   path,
		Reader: reader,
	}
	mock.lockWriteFile.Lock()
	mock.calls.WriteFile = append(mock.calls.WriteFile, callInfo)
	mock.lockWriteFile.Unlock()
	return mock.WriteFileFunc(path, reader)
}

// WriteFileCalls gets all the calls that were made to WriteFile.
// Check the length with:
//
//	len(mockedFileSystem.WriteFileCalls())
func (mock *MoqFileSystem) WriteFileCalls() []struct {
	Path   string
	Reader io.Reader
} {
	var calls []struct {
		Path   string
		Reader io.Reader
	}
	mock.lockWriteFile.RLock()
	calls = mock.calls.WriteFile
	mock.lockWriteFile.RUnlock()
	return calls
}
