// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package logger

import (
	"sync"
)

// Ensure that MoqLogger does implement Logger.
// If this is not the case, regenerate this file with mockery.
var _ Logger = &MoqLogger{}

// MoqLogger is a mock implementation of Logger.
//
//	func TestSomethingThatUsesLogger(t *testing.T) {
//
//		// make and configure a mocked Logger
//		mockedLogger := &MoqLogger{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			DebugFunc: func(format string, args ...any)  {
//				panic("mock out the Debug method")
//			},
//			ErrorFunc: func(format string, args ...any)  {
//				panic("mock out the Error method")
//			},
//			FailInteractiveProgressFunc: func(message string, err error)  {
//				panic("mock out the FailInteractiveProgress method")
//			},
//			FailPersistentProgressFunc: func(message string, err error)  {
//				panic("mock out the FailPersistentProgress method")
//			},
//			FailProgressFunc: func(message string, err error)  {
//				panic("mock out the FailProgress method")
//			},
//			FinishInteractiveProgressFunc: func(message string)  {
//				panic("mock out the FinishInteractiveProgress method")
//			},
//			FinishPersistentProgressFunc: func(message string)  {
//				panic("mock out the FinishPersistentProgress method")
//			},
//			FinishProgressFunc: func(message string)  {
//				panic("mock out the FinishProgress method")
//			},
//			InfoFunc: func(format string, args ...any)  {
//				panic("mock out the Info method")
//			},
//			LogAccomplishmentFunc: func(message string)  {
//				panic("mock out the LogAccomplishment method")
//			},
//			StartInteractiveProgressFunc: func(message string)  {
//				panic("mock out the StartInteractiveProgress method")
//			},
//			StartPersistentProgressFunc: func(message string)  {
//				panic("mock out the StartPersistentProgress method")
//			},
//			StartProgressFunc: func(message string)  {
//				panic("mock out the StartProgress method")
//			},
//			SuccessFunc: func(format string, args ...any)  {
//				panic("mock out the Success method")
//			},
//			TraceFunc: func(format string, args ...any)  {
//				panic("mock out the Trace method")
//			},
//			UpdateProgressFunc: func(message string)  {
//				panic("mock out the UpdateProgress method")
//			},
//			WarningFunc: func(format string, args ...any)  {
//				panic("mock out the Warning method")
//			},
//		}
//
//		// use mockedLogger in code that requires Logger
//		// and then make assertions.
//
//	}
type MoqLogger struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// DebugFunc mocks the Debug method.
	DebugFunc func(format string, args ...any)

	// ErrorFunc mocks the Error method.
	ErrorFunc func(format string, args ...any)

	// FailInteractiveProgressFunc mocks the FailInteractiveProgress method.
	FailInteractiveProgressFunc func(message string, err error)

	// FailPersistentProgressFunc mocks the FailPersistentProgress method.
	FailPersistentProgressFunc func(message string, err error)

	// FailProgressFunc mocks the FailProgress method.
	FailProgressFunc func(message string, err error)

	// FinishInteractiveProgressFunc mocks the FinishInteractiveProgress method.
	FinishInteractiveProgressFunc func(message string)

	// FinishPersistentProgressFunc mocks the FinishPersistentProgress method.
	FinishPersistentProgressFunc func(message string)

	// FinishProgressFunc mocks the FinishProgress method.
	FinishProgressFunc func(message string)

	// InfoFunc mocks the Info method.
	InfoFunc func(format string, args ...any)

	// LogAccomplishmentFunc mocks the LogAccomplishment method.
	LogAccomplishmentFunc func(message string)

	// StartInteractiveProgressFunc mocks the StartInteractiveProgress method.
	StartInteractiveProgressFunc func(message string)

	// StartPersistentProgressFunc mocks the StartPersistentProgress method.
	StartPersistentProgressFunc func(message string)

	// StartProgressFunc mocks the StartProgress method.
	StartProgressFunc func(message string)

	// SuccessFunc mocks the Success method.
	SuccessFunc func(format string, args ...any)

	// TraceFunc mocks the Trace method.
	TraceFunc func(format string, args ...any)

	// UpdateProgressFunc mocks the UpdateProgress method.
	UpdateProgressFunc func(message string)

	// WarningFunc mocks the Warning method.
	WarningFunc func(format string, args ...any)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// FailInteractiveProgress holds details about calls to the FailInteractiveProgress method.
		FailInteractiveProgress []struct {
			// Message is the message argument value.
			Message string
			// Err is the err argument value.
			Err error
		}
		// FailPersistentProgress holds details about calls to the FailPersistentProgress method.
		FailPersistentProgress []struct {
			// Message is the message argument value.
			Message string
			// Err is the err argument value.
			Err error
		}
		// FailProgress holds details about calls to the FailProgress method.
		FailProgress []struct {
			// Message is the message argument value.
			Message string
			// Err is the err argument value.
			Err error
		}
		// FinishInteractiveProgress holds details about calls to the FinishInteractiveProgress method.
		FinishInteractiveProgress []struct {
			// Message is the message argument value.
			Message string
		}
		// FinishPersistentProgress holds details about calls to the FinishPersistentProgress method.
		FinishPersistentProgress []struct {
			// Message is the message argument value.
			Message string
		}
		// FinishProgress holds details about calls to the FinishProgress method.
		FinishProgress []struct {
			// Message is the message argument value.
			Message string
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// LogAccomplishment holds details about calls to the LogAccomplishment method.
		LogAccomplishment []struct {
			// Message is the message argument value.
			Message string
		}
		// StartInteractiveProgress holds details about calls to the StartInteractiveProgress method.
		StartInteractiveProgress []struct {
			// Message is the message argument value.
			Message string
		}
		// StartPersistentProgress holds details about calls to the StartPersistentProgress method.
		StartPersistentProgress []struct {
			// Message is the message argument value.
			Message string
		}
		// StartProgress holds details about calls to the StartProgress method.
		StartProgress []struct {
			// Message is the message argument value.
			Message string
		}
		// Success holds details about calls to the Success method.
		Success []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// Trace holds details about calls to the Trace method.
		Trace []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// UpdateProgress holds details about calls to the UpdateProgress method.
		UpdateProgress []struct {
			// Message is the message argument value.
			Message string
		}
		// Warning holds details about calls to the Warning method.
		Warning []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
	}
	lockClose                     sync.RWMutex
	lockDebug                     sync.RWMutex
	lockError                     sync.RWMutex
	lockFailInteractiveProgress   sync.RWMutex
	lockFailPersistentProgress    sync.RWMutex
	lockFailProgress              sync.RWMutex
	lockFinishInteractiveProgress sync.RWMutex
	lockFinishPersistentProgress  sync.RWMutex
	lockFinishProgress            sync.RWMutex
	lockInfo                      sync.RWMutex
	lockLogAccomplishment         sync.RWMutex
	lockStartInteractiveProgress  sync.RWMutex
	lockStartPersistentProgress   sync.RWMutex
	lockStartProgress             sync.RWMutex
	lockSuccess                   sync.RWMutex
	lockTrace                     sync.RWMutex
	lockUpdateProgress            sync.RWMutex
	lockWarning                   sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MoqLogger) Close() error {
	if mock.CloseFunc == nil {
		panic("MoqLogger.CloseFunc: method is nil but Logger.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedLogger.CloseCalls())
func (mock *MoqLogger) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Debug calls DebugFunc.
func (mock *MoqLogger) Debug(format string, args ...any) {
	if mock.DebugFunc == nil {
		panic("MoqLogger.DebugFunc: method is nil but Logger.Debug was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	mock.lockDebug.Unlock()
	mock.DebugFunc(format, args...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//
//	len(mockedLogger.DebugCalls())
func (mock *MoqLogger) DebugCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockDebug.RLock()
	calls = mock.calls.Debug
	mock.lockDebug.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *MoqLogger) Error(format string, args ...any) {
	if mock.ErrorFunc == nil {
		panic("MoqLogger.ErrorFunc: method is nil but Logger.Error was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	mock.ErrorFunc(format, args...)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//
//	len(mockedLogger.ErrorCalls())
func (mock *MoqLogger) ErrorCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// FailInteractiveProgress calls FailInteractiveProgressFunc.
func (mock *MoqLogger) FailInteractiveProgress(message string, err error) {
	if mock.FailInteractiveProgressFunc == nil {
		panic("MoqLogger.FailInteractiveProgressFunc: method is nil but Logger.FailInteractiveProgress was just called")
	}
	callInfo := struct {
		Message string
		Err     error
	}{
		Message: message,
		Err:     err,
	}
	mock.lockFailInteractiveProgress.Lock()
	mock.calls.FailInteractiveProgress = append(mock.calls.FailInteractiveProgress, callInfo)
	mock.lockFailInteractiveProgress.Unlock()
	mock.FailInteractiveProgressFunc(message, err)
}

// FailInteractiveProgressCalls gets all the calls that were made to FailInteractiveProgress.
// Check the length with:
//
//	len(mockedLogger.FailInteractiveProgressCalls())
func (mock *MoqLogger) FailInteractiveProgressCalls() []struct {
	Message string
	Err     error
} {
	var calls []struct {
		Message string
		Err     error
	}
	mock.lockFailInteractiveProgress.RLock()
	calls = mock.calls.FailInteractiveProgress
	mock.lockFailInteractiveProgress.RUnlock()
	return calls
}

// FailPersistentProgress calls FailPersistentProgressFunc.
func (mock *MoqLogger) FailPersistentProgress(message string, err error) {
	if mock.FailPersistentProgressFunc == nil {
		panic("MoqLogger.FailPersistentProgressFunc: method is nil but Logger.FailPersistentProgress was just called")
	}
	callInfo := struct {
		Message string
		Err     error
	}{
		Message: message,
		Err:     err,
	}
	mock.lockFailPersistentProgress.Lock()
	mock.calls.FailPersistentProgress = append(mock.calls.FailPersistentProgress, callInfo)
	mock.lockFailPersistentProgress.Unlock()
	mock.FailPersistentProgressFunc(message, err)
}

// FailPersistentProgressCalls gets all the calls that were made to FailPersistentProgress.
// Check the length with:
//
//	len(mockedLogger.FailPersistentProgressCalls())
func (mock *MoqLogger) FailPersistentProgressCalls() []struct {
	Message string
	Err     error
} {
	var calls []struct {
		Message string
		Err     error
	}
	mock.lockFailPersistentProgress.RLock()
	calls = mock.calls.FailPersistentProgress
	mock.lockFailPersistentProgress.RUnlock()
	return calls
}

// FailProgress calls FailProgressFunc.
func (mock *MoqLogger) FailProgress(message string, err error) {
	if mock.FailProgressFunc == nil {
		panic("MoqLogger.FailProgressFunc: method is nil but Logger.FailProgress was just called")
	}
	callInfo := struct {
		Message string
		Err     error
	}{
		Message: message,
		Err:     err,
	}
	mock.lockFailProgress.Lock()
	mock.calls.FailProgress = append(mock.calls.FailProgress, callInfo)
	mock.lockFailProgress.Unlock()
	mock.FailProgressFunc(message, err)
}

// FailProgressCalls gets all the calls that were made to FailProgress.
// Check the length with:
//
//	len(mockedLogger.FailProgressCalls())
func (mock *MoqLogger) FailProgressCalls() []struct {
	Message string
	Err     error
} {
	var calls []struct {
		Message string
		Err     error
	}
	mock.lockFailProgress.RLock()
	calls = mock.calls.FailProgress
	mock.lockFailProgress.RUnlock()
	return calls
}

// FinishInteractiveProgress calls FinishInteractiveProgressFunc.
func (mock *MoqLogger) FinishInteractiveProgress(message string) {
	if mock.FinishInteractiveProgressFunc == nil {
		panic("MoqLogger.FinishInteractiveProgressFunc: method is nil but Logger.FinishInteractiveProgress was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockFinishInteractiveProgress.Lock()
	mock.calls.FinishInteractiveProgress = append(mock.calls.FinishInteractiveProgress, callInfo)
	mock.lockFinishInteractiveProgress.Unlock()
	mock.FinishInteractiveProgressFunc(message)
}

// FinishInteractiveProgressCalls gets all the calls that were made to FinishInteractiveProgress.
// Check the length with:
//
//	len(mockedLogger.FinishInteractiveProgressCalls())
func (mock *MoqLogger) FinishInteractiveProgressCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockFinishInteractiveProgress.RLock()
	calls = mock.calls.FinishInteractiveProgress
	mock.lockFinishInteractiveProgress.RUnlock()
	return calls
}

// FinishPersistentProgress calls FinishPersistentProgressFunc.
func (mock *MoqLogger) FinishPersistentProgress(message string) {
	if mock.FinishPersistentProgressFunc == nil {
		panic("MoqLogger.FinishPersistentProgressFunc: method is nil but Logger.FinishPersistentProgress was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockFinishPersistentProgress.Lock()
	mock.calls.FinishPersistentProgress = append(mock.calls.FinishPersistentProgress, callInfo)
	mock.lockFinishPersistentProgress.Unlock()
	mock.FinishPersistentProgressFunc(message)
}

// FinishPersistentProgressCalls gets all the calls that were made to FinishPersistentProgress.
// Check the length with:
//
//	len(mockedLogger.FinishPersistentProgressCalls())
func (mock *MoqLogger) FinishPersistentProgressCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockFinishPersistentProgress.RLock()
	calls = mock.calls.FinishPersistentProgress
	mock.lockFinishPersistentProgress.RUnlock()
	return calls
}

// FinishProgress calls FinishProgressFunc.
func (mock *MoqLogger) FinishProgress(message string) {
	if mock.FinishProgressFunc == nil {
		panic("MoqLogger.FinishProgressFunc: method is nil but Logger.FinishProgress was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockFinishProgress.Lock()
	mock.calls.FinishProgress = append(mock.calls.FinishProgress, callInfo)
	mock.lockFinishProgress.Unlock()
	mock.FinishProgressFunc(message)
}

// FinishProgressCalls gets all the calls that were made to FinishProgress.
// Check the length with:
//
//	len(mockedLogger.FinishProgressCalls())
func (mock *MoqLogger) FinishProgressCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockFinishProgress.RLock()
	calls = mock.calls.FinishProgress
	mock.lockFinishProgress.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *MoqLogger) Info(format string, args ...any) {
	if mock.InfoFunc == nil {
		panic("MoqLogger.InfoFunc: method is nil but Logger.Info was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	mock.InfoFunc(format, args...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedLogger.InfoCalls())
func (mock *MoqLogger) InfoCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// LogAccomplishment calls LogAccomplishmentFunc.
func (mock *MoqLogger) LogAccomplishment(message string) {
	if mock.LogAccomplishmentFunc == nil {
		panic("MoqLogger.LogAccomplishmentFunc: method is nil but Logger.LogAccomplishment was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockLogAccomplishment.Lock()
	mock.calls.LogAccomplishment = append(mock.calls.LogAccomplishment, callInfo)
	mock.lockLogAccomplishment.Unlock()
	mock.LogAccomplishmentFunc(message)
}

// LogAccomplishmentCalls gets all the calls that were made to LogAccomplishment.
// Check the length with:
//
//	len(mockedLogger.LogAccomplishmentCalls())
func (mock *MoqLogger) LogAccomplishmentCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockLogAccomplishment.RLock()
	calls = mock.calls.LogAccomplishment
	mock.lockLogAccomplishment.RUnlock()
	return calls
}

// StartInteractiveProgress calls StartInteractiveProgressFunc.
func (mock *MoqLogger) StartInteractiveProgress(message string) {
	if mock.StartInteractiveProgressFunc == nil {
		panic("MoqLogger.StartInteractiveProgressFunc: method is nil but Logger.StartInteractiveProgress was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockStartInteractiveProgress.Lock()
	mock.calls.StartInteractiveProgress = append(mock.calls.StartInteractiveProgress, callInfo)
	mock.lockStartInteractiveProgress.Unlock()
	mock.StartInteractiveProgressFunc(message)
}

// StartInteractiveProgressCalls gets all the calls that were made to StartInteractiveProgress.
// Check the length with:
//
//	len(mockedLogger.StartInteractiveProgressCalls())
func (mock *MoqLogger) StartInteractiveProgressCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockStartInteractiveProgress.RLock()
	calls = mock.calls.StartInteractiveProgress
	mock.lockStartInteractiveProgress.RUnlock()
	return calls
}

// StartPersistentProgress calls StartPersistentProgressFunc.
func (mock *MoqLogger) StartPersistentProgress(message string) {
	if mock.StartPersistentProgressFunc == nil {
		panic("MoqLogger.StartPersistentProgressFunc: method is nil but Logger.StartPersistentProgress was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockStartPersistentProgress.Lock()
	mock.calls.StartPersistentProgress = append(mock.calls.StartPersistentProgress, callInfo)
	mock.lockStartPersistentProgress.Unlock()
	mock.StartPersistentProgressFunc(message)
}

// StartPersistentProgressCalls gets all the calls that were made to StartPersistentProgress.
// Check the length with:
//
//	len(mockedLogger.StartPersistentProgressCalls())
func (mock *MoqLogger) StartPersistentProgressCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockStartPersistentProgress.RLock()
	calls = mock.calls.StartPersistentProgress
	mock.lockStartPersistentProgress.RUnlock()
	return calls
}

// StartProgress calls StartProgressFunc.
func (mock *MoqLogger) StartProgress(message string) {
	if mock.StartProgressFunc == nil {
		panic("MoqLogger.StartProgressFunc: method is nil but Logger.StartProgress was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockStartProgress.Lock()
	mock.calls.StartProgress = append(mock.calls.StartProgress, callInfo)
	mock.lockStartProgress.Unlock()
	mock.StartProgressFunc(message)
}

// StartProgressCalls gets all the calls that were made to StartProgress.
// Check the length with:
//
//	len(mockedLogger.StartProgressCalls())
func (mock *MoqLogger) StartProgressCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockStartProgress.RLock()
	calls = mock.calls.StartProgress
	mock.lockStartProgress.RUnlock()
	return calls
}

// Success calls SuccessFunc.
func (mock *MoqLogger) Success(format string, args ...any) {
	if mock.SuccessFunc == nil {
		panic("MoqLogger.SuccessFunc: method is nil but Logger.Success was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockSuccess.Lock()
	mock.calls.Success = append(mock.calls.Success, callInfo)
	mock.lockSuccess.Unlock()
	mock.SuccessFunc(format, args...)
}

// SuccessCalls gets all the calls that were made to Success.
// Check the length with:
//
//	len(mockedLogger.SuccessCalls())
func (mock *MoqLogger) SuccessCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockSuccess.RLock()
	calls = mock.calls.Success
	mock.lockSuccess.RUnlock()
	return calls
}

// Trace calls TraceFunc.
func (mock *MoqLogger) Trace(format string, args ...any) {
	if mock.TraceFunc == nil {
		panic("MoqLogger.TraceFunc: method is nil but Logger.Trace was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockTrace.Lock()
	mock.calls.Trace = append(mock.calls.Trace, callInfo)
	mock.lockTrace.Unlock()
	mock.TraceFunc(format, args...)
}

// TraceCalls gets all the calls that were made to Trace.
// Check the length with:
//
//	len(mockedLogger.TraceCalls())
func (mock *MoqLogger) TraceCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockTrace.RLock()
	calls = mock.calls.Trace
	mock.lockTrace.RUnlock()
	return calls
}

// UpdateProgress calls UpdateProgressFunc.
func (mock *MoqLogger) UpdateProgress(message string) {
	if mock.UpdateProgressFunc == nil {
		panic("MoqLogger.UpdateProgressFunc: method is nil but Logger.UpdateProgress was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockUpdateProgress.Lock()
	mock.calls.UpdateProgress = append(mock.calls.UpdateProgress, callInfo)
	mock.lockUpdateProgress.Unlock()
	mock.UpdateProgressFunc(message)
}

// UpdateProgressCalls gets all the calls that were made to UpdateProgress.
// Check the length with:
//
//	len(mockedLogger.UpdateProgressCalls())
func (mock *MoqLogger) UpdateProgressCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockUpdateProgress.RLock()
	calls = mock.calls.UpdateProgress
	mock.lockUpdateProgress.RUnlock()
	return calls
}

// Warning calls WarningFunc.
func (mock *MoqLogger) Warning(format string, args ...any) {
	if mock.WarningFunc == nil {
		panic("MoqLogger.WarningFunc: method is nil but Logger.Warning was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockWarning.Lock()
	mock.calls.Warning = append(mock.calls.Warning, callInfo)
	mock.lockWarning.Unlock()
	mock.WarningFunc(format, args...)
}

// WarningCalls gets all the calls that were made to Warning.
// Check the length with:
//
//	len(mockedLogger.WarningCalls())
func (mock *MoqLogger) WarningCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockWarning.RLock()
	calls = mock.calls.Warning
	mock.lockWarning.RUnlock()
	return calls
}
