// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package logger

import (
	"sync"
)

// Ensure that MoqLogger does implement Logger.
// If this is not the case, regenerate this file with mockery.
var _ Logger = &MoqLogger{}

// MoqLogger is a mock implementation of Logger.
//
//	func TestSomethingThatUsesLogger(t *testing.T) {
//
//		// make and configure a mocked Logger
//		mockedLogger := &MoqLogger{
//			DebugFunc: func(format string, args ...any)  {
//				panic("mock out the Debug method")
//			},
//			ErrorFunc: func(format string, args ...any)  {
//				panic("mock out the Error method")
//			},
//			FailProgressFunc: func(message string, err error)  {
//				panic("mock out the FailProgress method")
//			},
//			FinishProgressFunc: func(message string)  {
//				panic("mock out the FinishProgress method")
//			},
//			InfoFunc: func(format string, args ...any)  {
//				panic("mock out the Info method")
//			},
//			StartProgressFunc: func(message string)  {
//				panic("mock out the StartProgress method")
//			},
//			SuccessFunc: func(format string, args ...any)  {
//				panic("mock out the Success method")
//			},
//			TraceFunc: func(format string, args ...any)  {
//				panic("mock out the Trace method")
//			},
//			UpdateProgressFunc: func(message string)  {
//				panic("mock out the UpdateProgress method")
//			},
//			WarningFunc: func(format string, args ...any)  {
//				panic("mock out the Warning method")
//			},
//		}
//
//		// use mockedLogger in code that requires Logger
//		// and then make assertions.
//
//	}
type MoqLogger struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(format string, args ...any)

	// ErrorFunc mocks the Error method.
	ErrorFunc func(format string, args ...any)

	// FailProgressFunc mocks the FailProgress method.
	FailProgressFunc func(message string, err error)

	// FinishProgressFunc mocks the FinishProgress method.
	FinishProgressFunc func(message string)

	// InfoFunc mocks the Info method.
	InfoFunc func(format string, args ...any)

	// StartProgressFunc mocks the StartProgress method.
	StartProgressFunc func(message string)

	// SuccessFunc mocks the Success method.
	SuccessFunc func(format string, args ...any)

	// TraceFunc mocks the Trace method.
	TraceFunc func(format string, args ...any)

	// UpdateProgressFunc mocks the UpdateProgress method.
	UpdateProgressFunc func(message string)

	// WarningFunc mocks the Warning method.
	WarningFunc func(format string, args ...any)

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// FailProgress holds details about calls to the FailProgress method.
		FailProgress []struct {
			// Message is the message argument value.
			Message string
			// Err is the err argument value.
			Err error
		}
		// FinishProgress holds details about calls to the FinishProgress method.
		FinishProgress []struct {
			// Message is the message argument value.
			Message string
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// StartProgress holds details about calls to the StartProgress method.
		StartProgress []struct {
			// Message is the message argument value.
			Message string
		}
		// Success holds details about calls to the Success method.
		Success []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// Trace holds details about calls to the Trace method.
		Trace []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
		// UpdateProgress holds details about calls to the UpdateProgress method.
		UpdateProgress []struct {
			// Message is the message argument value.
			Message string
		}
		// Warning holds details about calls to the Warning method.
		Warning []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []any
		}
	}
	lockDebug          sync.RWMutex
	lockError          sync.RWMutex
	lockFailProgress   sync.RWMutex
	lockFinishProgress sync.RWMutex
	lockInfo           sync.RWMutex
	lockStartProgress  sync.RWMutex
	lockSuccess        sync.RWMutex
	lockTrace          sync.RWMutex
	lockUpdateProgress sync.RWMutex
	lockWarning        sync.RWMutex
}

// Debug calls DebugFunc.
func (mock *MoqLogger) Debug(format string, args ...any) {
	if mock.DebugFunc == nil {
		panic("MoqLogger.DebugFunc: method is nil but Logger.Debug was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	mock.lockDebug.Unlock()
	mock.DebugFunc(format, args...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//
//	len(mockedLogger.DebugCalls())
func (mock *MoqLogger) DebugCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockDebug.RLock()
	calls = mock.calls.Debug
	mock.lockDebug.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *MoqLogger) Error(format string, args ...any) {
	if mock.ErrorFunc == nil {
		panic("MoqLogger.ErrorFunc: method is nil but Logger.Error was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	mock.ErrorFunc(format, args...)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//
//	len(mockedLogger.ErrorCalls())
func (mock *MoqLogger) ErrorCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// FailProgress calls FailProgressFunc.
func (mock *MoqLogger) FailProgress(message string, err error) {
	if mock.FailProgressFunc == nil {
		panic("MoqLogger.FailProgressFunc: method is nil but Logger.FailProgress was just called")
	}
	callInfo := struct {
		Message string
		Err     error
	}{
		Message: message,
		Err:     err,
	}
	mock.lockFailProgress.Lock()
	mock.calls.FailProgress = append(mock.calls.FailProgress, callInfo)
	mock.lockFailProgress.Unlock()
	mock.FailProgressFunc(message, err)
}

// FailProgressCalls gets all the calls that were made to FailProgress.
// Check the length with:
//
//	len(mockedLogger.FailProgressCalls())
func (mock *MoqLogger) FailProgressCalls() []struct {
	Message string
	Err     error
} {
	var calls []struct {
		Message string
		Err     error
	}
	mock.lockFailProgress.RLock()
	calls = mock.calls.FailProgress
	mock.lockFailProgress.RUnlock()
	return calls
}

// FinishProgress calls FinishProgressFunc.
func (mock *MoqLogger) FinishProgress(message string) {
	if mock.FinishProgressFunc == nil {
		panic("MoqLogger.FinishProgressFunc: method is nil but Logger.FinishProgress was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockFinishProgress.Lock()
	mock.calls.FinishProgress = append(mock.calls.FinishProgress, callInfo)
	mock.lockFinishProgress.Unlock()
	mock.FinishProgressFunc(message)
}

// FinishProgressCalls gets all the calls that were made to FinishProgress.
// Check the length with:
//
//	len(mockedLogger.FinishProgressCalls())
func (mock *MoqLogger) FinishProgressCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockFinishProgress.RLock()
	calls = mock.calls.FinishProgress
	mock.lockFinishProgress.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *MoqLogger) Info(format string, args ...any) {
	if mock.InfoFunc == nil {
		panic("MoqLogger.InfoFunc: method is nil but Logger.Info was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	mock.InfoFunc(format, args...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedLogger.InfoCalls())
func (mock *MoqLogger) InfoCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// StartProgress calls StartProgressFunc.
func (mock *MoqLogger) StartProgress(message string) {
	if mock.StartProgressFunc == nil {
		panic("MoqLogger.StartProgressFunc: method is nil but Logger.StartProgress was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockStartProgress.Lock()
	mock.calls.StartProgress = append(mock.calls.StartProgress, callInfo)
	mock.lockStartProgress.Unlock()
	mock.StartProgressFunc(message)
}

// StartProgressCalls gets all the calls that were made to StartProgress.
// Check the length with:
//
//	len(mockedLogger.StartProgressCalls())
func (mock *MoqLogger) StartProgressCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockStartProgress.RLock()
	calls = mock.calls.StartProgress
	mock.lockStartProgress.RUnlock()
	return calls
}

// Success calls SuccessFunc.
func (mock *MoqLogger) Success(format string, args ...any) {
	if mock.SuccessFunc == nil {
		panic("MoqLogger.SuccessFunc: method is nil but Logger.Success was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockSuccess.Lock()
	mock.calls.Success = append(mock.calls.Success, callInfo)
	mock.lockSuccess.Unlock()
	mock.SuccessFunc(format, args...)
}

// SuccessCalls gets all the calls that were made to Success.
// Check the length with:
//
//	len(mockedLogger.SuccessCalls())
func (mock *MoqLogger) SuccessCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockSuccess.RLock()
	calls = mock.calls.Success
	mock.lockSuccess.RUnlock()
	return calls
}

// Trace calls TraceFunc.
func (mock *MoqLogger) Trace(format string, args ...any) {
	if mock.TraceFunc == nil {
		panic("MoqLogger.TraceFunc: method is nil but Logger.Trace was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockTrace.Lock()
	mock.calls.Trace = append(mock.calls.Trace, callInfo)
	mock.lockTrace.Unlock()
	mock.TraceFunc(format, args...)
}

// TraceCalls gets all the calls that were made to Trace.
// Check the length with:
//
//	len(mockedLogger.TraceCalls())
func (mock *MoqLogger) TraceCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockTrace.RLock()
	calls = mock.calls.Trace
	mock.lockTrace.RUnlock()
	return calls
}

// UpdateProgress calls UpdateProgressFunc.
func (mock *MoqLogger) UpdateProgress(message string) {
	if mock.UpdateProgressFunc == nil {
		panic("MoqLogger.UpdateProgressFunc: method is nil but Logger.UpdateProgress was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockUpdateProgress.Lock()
	mock.calls.UpdateProgress = append(mock.calls.UpdateProgress, callInfo)
	mock.lockUpdateProgress.Unlock()
	mock.UpdateProgressFunc(message)
}

// UpdateProgressCalls gets all the calls that were made to UpdateProgress.
// Check the length with:
//
//	len(mockedLogger.UpdateProgressCalls())
func (mock *MoqLogger) UpdateProgressCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockUpdateProgress.RLock()
	calls = mock.calls.UpdateProgress
	mock.lockUpdateProgress.RUnlock()
	return calls
}

// Warning calls WarningFunc.
func (mock *MoqLogger) Warning(format string, args ...any) {
	if mock.WarningFunc == nil {
		panic("MoqLogger.WarningFunc: method is nil but Logger.Warning was just called")
	}
	callInfo := struct {
		Format string
		Args   []any
	}{
		Format: format,
		Args:   args,
	}
	mock.lockWarning.Lock()
	mock.calls.Warning = append(mock.calls.Warning, callInfo)
	mock.lockWarning.Unlock()
	mock.WarningFunc(format, args...)
}

// WarningCalls gets all the calls that were made to Warning.
// Check the length with:
//
//	len(mockedLogger.WarningCalls())
func (mock *MoqLogger) WarningCalls() []struct {
	Format string
	Args   []any
} {
	var calls []struct {
		Format string
		Args   []any
	}
	mock.lockWarning.RLock()
	calls = mock.calls.Warning
	mock.lockWarning.RUnlock()
	return calls
}
