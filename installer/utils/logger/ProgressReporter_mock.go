// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package logger

import (
	"sync"
)

// Ensure that MoqProgressReporter does implement ProgressReporter.
// If this is not the case, regenerate this file with mockery.
var _ ProgressReporter = &MoqProgressReporter{}

// MoqProgressReporter is a mock implementation of ProgressReporter.
//
//	func TestSomethingThatUsesProgressReporter(t *testing.T) {
//
//		// make and configure a mocked ProgressReporter
//		mockedProgressReporter := &MoqProgressReporter{
//			ClearFunc: func()  {
//				panic("mock out the Clear method")
//			},
//			FailFunc: func(message string, err error)  {
//				panic("mock out the Fail method")
//			},
//			FinishFunc: func(message string)  {
//				panic("mock out the Finish method")
//			},
//			IsActiveFunc: func() bool {
//				panic("mock out the IsActive method")
//			},
//			StartFunc: func(message string)  {
//				panic("mock out the Start method")
//			},
//			UpdateFunc: func(message string)  {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedProgressReporter in code that requires ProgressReporter
//		// and then make assertions.
//
//	}
type MoqProgressReporter struct {
	// ClearFunc mocks the Clear method.
	ClearFunc func()

	// FailFunc mocks the Fail method.
	FailFunc func(message string, err error)

	// FinishFunc mocks the Finish method.
	FinishFunc func(message string)

	// IsActiveFunc mocks the IsActive method.
	IsActiveFunc func() bool

	// StartFunc mocks the Start method.
	StartFunc func(message string)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(message string)

	// calls tracks calls to the methods.
	calls struct {
		// Clear holds details about calls to the Clear method.
		Clear []struct {
		}
		// Fail holds details about calls to the Fail method.
		Fail []struct {
			// Message is the message argument value.
			Message string
			// Err is the err argument value.
			Err error
		}
		// Finish holds details about calls to the Finish method.
		Finish []struct {
			// Message is the message argument value.
			Message string
		}
		// IsActive holds details about calls to the IsActive method.
		IsActive []struct {
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Message is the message argument value.
			Message string
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Message is the message argument value.
			Message string
		}
	}
	lockClear    sync.RWMutex
	lockFail     sync.RWMutex
	lockFinish   sync.RWMutex
	lockIsActive sync.RWMutex
	lockStart    sync.RWMutex
	lockUpdate   sync.RWMutex
}

// Clear calls ClearFunc.
func (mock *MoqProgressReporter) Clear() {
	if mock.ClearFunc == nil {
		panic("MoqProgressReporter.ClearFunc: method is nil but ProgressReporter.Clear was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClear.Lock()
	mock.calls.Clear = append(mock.calls.Clear, callInfo)
	mock.lockClear.Unlock()
	mock.ClearFunc()
}

// ClearCalls gets all the calls that were made to Clear.
// Check the length with:
//
//	len(mockedProgressReporter.ClearCalls())
func (mock *MoqProgressReporter) ClearCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClear.RLock()
	calls = mock.calls.Clear
	mock.lockClear.RUnlock()
	return calls
}

// Fail calls FailFunc.
func (mock *MoqProgressReporter) Fail(message string, err error) {
	if mock.FailFunc == nil {
		panic("MoqProgressReporter.FailFunc: method is nil but ProgressReporter.Fail was just called")
	}
	callInfo := struct {
		Message string
		Err     error
	}{
		Message: message,
		Err:     err,
	}
	mock.lockFail.Lock()
	mock.calls.Fail = append(mock.calls.Fail, callInfo)
	mock.lockFail.Unlock()
	mock.FailFunc(message, err)
}

// FailCalls gets all the calls that were made to Fail.
// Check the length with:
//
//	len(mockedProgressReporter.FailCalls())
func (mock *MoqProgressReporter) FailCalls() []struct {
	Message string
	Err     error
} {
	var calls []struct {
		Message string
		Err     error
	}
	mock.lockFail.RLock()
	calls = mock.calls.Fail
	mock.lockFail.RUnlock()
	return calls
}

// Finish calls FinishFunc.
func (mock *MoqProgressReporter) Finish(message string) {
	if mock.FinishFunc == nil {
		panic("MoqProgressReporter.FinishFunc: method is nil but ProgressReporter.Finish was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockFinish.Lock()
	mock.calls.Finish = append(mock.calls.Finish, callInfo)
	mock.lockFinish.Unlock()
	mock.FinishFunc(message)
}

// FinishCalls gets all the calls that were made to Finish.
// Check the length with:
//
//	len(mockedProgressReporter.FinishCalls())
func (mock *MoqProgressReporter) FinishCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockFinish.RLock()
	calls = mock.calls.Finish
	mock.lockFinish.RUnlock()
	return calls
}

// IsActive calls IsActiveFunc.
func (mock *MoqProgressReporter) IsActive() bool {
	if mock.IsActiveFunc == nil {
		panic("MoqProgressReporter.IsActiveFunc: method is nil but ProgressReporter.IsActive was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsActive.Lock()
	mock.calls.IsActive = append(mock.calls.IsActive, callInfo)
	mock.lockIsActive.Unlock()
	return mock.IsActiveFunc()
}

// IsActiveCalls gets all the calls that were made to IsActive.
// Check the length with:
//
//	len(mockedProgressReporter.IsActiveCalls())
func (mock *MoqProgressReporter) IsActiveCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsActive.RLock()
	calls = mock.calls.IsActive
	mock.lockIsActive.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *MoqProgressReporter) Start(message string) {
	if mock.StartFunc == nil {
		panic("MoqProgressReporter.StartFunc: method is nil but ProgressReporter.Start was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	mock.StartFunc(message)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedProgressReporter.StartCalls())
func (mock *MoqProgressReporter) StartCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *MoqProgressReporter) Update(message string) {
	if mock.UpdateFunc == nil {
		panic("MoqProgressReporter.UpdateFunc: method is nil but ProgressReporter.Update was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	mock.UpdateFunc(message)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedProgressReporter.UpdateCalls())
func (mock *MoqProgressReporter) UpdateCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
