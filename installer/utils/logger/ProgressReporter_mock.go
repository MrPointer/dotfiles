// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package logger

import (
	"sync"
)

// Ensure that MoqProgressReporter does implement ProgressReporter.
// If this is not the case, regenerate this file with mockery.
var _ ProgressReporter = &MoqProgressReporter{}

// MoqProgressReporter is a mock implementation of ProgressReporter.
//
//	func TestSomethingThatUsesProgressReporter(t *testing.T) {
//
//		// make and configure a mocked ProgressReporter
//		mockedProgressReporter := &MoqProgressReporter{
//			ClearFunc: func()  {
//				panic("mock out the Clear method")
//			},
//			FailFunc: func(message string, err error)  {
//				panic("mock out the Fail method")
//			},
//			FailPersistentFunc: func(message string, err error)  {
//				panic("mock out the FailPersistent method")
//			},
//			FinishFunc: func(message string)  {
//				panic("mock out the Finish method")
//			},
//			FinishPersistentFunc: func(message string)  {
//				panic("mock out the FinishPersistent method")
//			},
//			IsActiveFunc: func() bool {
//				panic("mock out the IsActive method")
//			},
//			LogAccomplishmentFunc: func(message string)  {
//				panic("mock out the LogAccomplishment method")
//			},
//			StartFunc: func(message string)  {
//				panic("mock out the Start method")
//			},
//			StartPersistentFunc: func(message string)  {
//				panic("mock out the StartPersistent method")
//			},
//			UpdateFunc: func(message string)  {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedProgressReporter in code that requires ProgressReporter
//		// and then make assertions.
//
//	}
type MoqProgressReporter struct {
	// ClearFunc mocks the Clear method.
	ClearFunc func()

	// FailFunc mocks the Fail method.
	FailFunc func(message string, err error)

	// FailPersistentFunc mocks the FailPersistent method.
	FailPersistentFunc func(message string, err error)

	// FinishFunc mocks the Finish method.
	FinishFunc func(message string)

	// FinishPersistentFunc mocks the FinishPersistent method.
	FinishPersistentFunc func(message string)

	// IsActiveFunc mocks the IsActive method.
	IsActiveFunc func() bool

	// LogAccomplishmentFunc mocks the LogAccomplishment method.
	LogAccomplishmentFunc func(message string)

	// StartFunc mocks the Start method.
	StartFunc func(message string)

	// StartPersistentFunc mocks the StartPersistent method.
	StartPersistentFunc func(message string)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(message string)

	// calls tracks calls to the methods.
	calls struct {
		// Clear holds details about calls to the Clear method.
		Clear []struct {
		}
		// Fail holds details about calls to the Fail method.
		Fail []struct {
			// Message is the message argument value.
			Message string
			// Err is the err argument value.
			Err error
		}
		// FailPersistent holds details about calls to the FailPersistent method.
		FailPersistent []struct {
			// Message is the message argument value.
			Message string
			// Err is the err argument value.
			Err error
		}
		// Finish holds details about calls to the Finish method.
		Finish []struct {
			// Message is the message argument value.
			Message string
		}
		// FinishPersistent holds details about calls to the FinishPersistent method.
		FinishPersistent []struct {
			// Message is the message argument value.
			Message string
		}
		// IsActive holds details about calls to the IsActive method.
		IsActive []struct {
		}
		// LogAccomplishment holds details about calls to the LogAccomplishment method.
		LogAccomplishment []struct {
			// Message is the message argument value.
			Message string
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Message is the message argument value.
			Message string
		}
		// StartPersistent holds details about calls to the StartPersistent method.
		StartPersistent []struct {
			// Message is the message argument value.
			Message string
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Message is the message argument value.
			Message string
		}
	}
	lockClear             sync.RWMutex
	lockFail              sync.RWMutex
	lockFailPersistent    sync.RWMutex
	lockFinish            sync.RWMutex
	lockFinishPersistent  sync.RWMutex
	lockIsActive          sync.RWMutex
	lockLogAccomplishment sync.RWMutex
	lockStart             sync.RWMutex
	lockStartPersistent   sync.RWMutex
	lockUpdate            sync.RWMutex
}

// Clear calls ClearFunc.
func (mock *MoqProgressReporter) Clear() {
	if mock.ClearFunc == nil {
		panic("MoqProgressReporter.ClearFunc: method is nil but ProgressReporter.Clear was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClear.Lock()
	mock.calls.Clear = append(mock.calls.Clear, callInfo)
	mock.lockClear.Unlock()
	mock.ClearFunc()
}

// ClearCalls gets all the calls that were made to Clear.
// Check the length with:
//
//	len(mockedProgressReporter.ClearCalls())
func (mock *MoqProgressReporter) ClearCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClear.RLock()
	calls = mock.calls.Clear
	mock.lockClear.RUnlock()
	return calls
}

// Fail calls FailFunc.
func (mock *MoqProgressReporter) Fail(message string, err error) {
	if mock.FailFunc == nil {
		panic("MoqProgressReporter.FailFunc: method is nil but ProgressReporter.Fail was just called")
	}
	callInfo := struct {
		Message string
		Err     error
	}{
		Message: message,
		Err:     err,
	}
	mock.lockFail.Lock()
	mock.calls.Fail = append(mock.calls.Fail, callInfo)
	mock.lockFail.Unlock()
	mock.FailFunc(message, err)
}

// FailCalls gets all the calls that were made to Fail.
// Check the length with:
//
//	len(mockedProgressReporter.FailCalls())
func (mock *MoqProgressReporter) FailCalls() []struct {
	Message string
	Err     error
} {
	var calls []struct {
		Message string
		Err     error
	}
	mock.lockFail.RLock()
	calls = mock.calls.Fail
	mock.lockFail.RUnlock()
	return calls
}

// FailPersistent calls FailPersistentFunc.
func (mock *MoqProgressReporter) FailPersistent(message string, err error) {
	if mock.FailPersistentFunc == nil {
		panic("MoqProgressReporter.FailPersistentFunc: method is nil but ProgressReporter.FailPersistent was just called")
	}
	callInfo := struct {
		Message string
		Err     error
	}{
		Message: message,
		Err:     err,
	}
	mock.lockFailPersistent.Lock()
	mock.calls.FailPersistent = append(mock.calls.FailPersistent, callInfo)
	mock.lockFailPersistent.Unlock()
	mock.FailPersistentFunc(message, err)
}

// FailPersistentCalls gets all the calls that were made to FailPersistent.
// Check the length with:
//
//	len(mockedProgressReporter.FailPersistentCalls())
func (mock *MoqProgressReporter) FailPersistentCalls() []struct {
	Message string
	Err     error
} {
	var calls []struct {
		Message string
		Err     error
	}
	mock.lockFailPersistent.RLock()
	calls = mock.calls.FailPersistent
	mock.lockFailPersistent.RUnlock()
	return calls
}

// Finish calls FinishFunc.
func (mock *MoqProgressReporter) Finish(message string) {
	if mock.FinishFunc == nil {
		panic("MoqProgressReporter.FinishFunc: method is nil but ProgressReporter.Finish was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockFinish.Lock()
	mock.calls.Finish = append(mock.calls.Finish, callInfo)
	mock.lockFinish.Unlock()
	mock.FinishFunc(message)
}

// FinishCalls gets all the calls that were made to Finish.
// Check the length with:
//
//	len(mockedProgressReporter.FinishCalls())
func (mock *MoqProgressReporter) FinishCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockFinish.RLock()
	calls = mock.calls.Finish
	mock.lockFinish.RUnlock()
	return calls
}

// FinishPersistent calls FinishPersistentFunc.
func (mock *MoqProgressReporter) FinishPersistent(message string) {
	if mock.FinishPersistentFunc == nil {
		panic("MoqProgressReporter.FinishPersistentFunc: method is nil but ProgressReporter.FinishPersistent was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockFinishPersistent.Lock()
	mock.calls.FinishPersistent = append(mock.calls.FinishPersistent, callInfo)
	mock.lockFinishPersistent.Unlock()
	mock.FinishPersistentFunc(message)
}

// FinishPersistentCalls gets all the calls that were made to FinishPersistent.
// Check the length with:
//
//	len(mockedProgressReporter.FinishPersistentCalls())
func (mock *MoqProgressReporter) FinishPersistentCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockFinishPersistent.RLock()
	calls = mock.calls.FinishPersistent
	mock.lockFinishPersistent.RUnlock()
	return calls
}

// IsActive calls IsActiveFunc.
func (mock *MoqProgressReporter) IsActive() bool {
	if mock.IsActiveFunc == nil {
		panic("MoqProgressReporter.IsActiveFunc: method is nil but ProgressReporter.IsActive was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsActive.Lock()
	mock.calls.IsActive = append(mock.calls.IsActive, callInfo)
	mock.lockIsActive.Unlock()
	return mock.IsActiveFunc()
}

// IsActiveCalls gets all the calls that were made to IsActive.
// Check the length with:
//
//	len(mockedProgressReporter.IsActiveCalls())
func (mock *MoqProgressReporter) IsActiveCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsActive.RLock()
	calls = mock.calls.IsActive
	mock.lockIsActive.RUnlock()
	return calls
}

// LogAccomplishment calls LogAccomplishmentFunc.
func (mock *MoqProgressReporter) LogAccomplishment(message string) {
	if mock.LogAccomplishmentFunc == nil {
		panic("MoqProgressReporter.LogAccomplishmentFunc: method is nil but ProgressReporter.LogAccomplishment was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockLogAccomplishment.Lock()
	mock.calls.LogAccomplishment = append(mock.calls.LogAccomplishment, callInfo)
	mock.lockLogAccomplishment.Unlock()
	mock.LogAccomplishmentFunc(message)
}

// LogAccomplishmentCalls gets all the calls that were made to LogAccomplishment.
// Check the length with:
//
//	len(mockedProgressReporter.LogAccomplishmentCalls())
func (mock *MoqProgressReporter) LogAccomplishmentCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockLogAccomplishment.RLock()
	calls = mock.calls.LogAccomplishment
	mock.lockLogAccomplishment.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *MoqProgressReporter) Start(message string) {
	if mock.StartFunc == nil {
		panic("MoqProgressReporter.StartFunc: method is nil but ProgressReporter.Start was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	mock.StartFunc(message)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedProgressReporter.StartCalls())
func (mock *MoqProgressReporter) StartCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// StartPersistent calls StartPersistentFunc.
func (mock *MoqProgressReporter) StartPersistent(message string) {
	if mock.StartPersistentFunc == nil {
		panic("MoqProgressReporter.StartPersistentFunc: method is nil but ProgressReporter.StartPersistent was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockStartPersistent.Lock()
	mock.calls.StartPersistent = append(mock.calls.StartPersistent, callInfo)
	mock.lockStartPersistent.Unlock()
	mock.StartPersistentFunc(message)
}

// StartPersistentCalls gets all the calls that were made to StartPersistent.
// Check the length with:
//
//	len(mockedProgressReporter.StartPersistentCalls())
func (mock *MoqProgressReporter) StartPersistentCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockStartPersistent.RLock()
	calls = mock.calls.StartPersistent
	mock.lockStartPersistent.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *MoqProgressReporter) Update(message string) {
	if mock.UpdateFunc == nil {
		panic("MoqProgressReporter.UpdateFunc: method is nil but ProgressReporter.Update was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	mock.UpdateFunc(message)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedProgressReporter.UpdateCalls())
func (mock *MoqProgressReporter) UpdateCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
