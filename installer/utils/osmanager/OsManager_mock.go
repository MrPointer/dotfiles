// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package osmanager

import (
	"os"
	"sync"
)

// Ensure that MoqOsManager does implement OsManager.
// If this is not the case, regenerate this file with mockery.
var _ OsManager = &MoqOsManager{}

// MoqOsManager is a mock implementation of OsManager.
//
//	func TestSomethingThatUsesOsManager(t *testing.T) {
//
//		// make and configure a mocked OsManager
//		mockedOsManager := &MoqOsManager{
//			AddSudoAccessFunc: func(username string) error {
//				panic("mock out the AddSudoAccess method")
//			},
//			AddUserFunc: func(username string) error {
//				panic("mock out the AddUser method")
//			},
//			AddUserToGroupFunc: func(username string, group string) error {
//				panic("mock out the AddUserToGroup method")
//			},
//			GetFileOwnerFunc: func(path string) (string, error) {
//				panic("mock out the GetFileOwner method")
//			},
//			GetProgramPathFunc: func(program string) (string, error) {
//				panic("mock out the GetProgramPath method")
//			},
//			GetProgramVersionFunc: func(program string, versionExtractor VersionExtractor, queryArgs ...string) (string, error) {
//				panic("mock out the GetProgramVersion method")
//			},
//			ProgramExistsFunc: func(program string) (bool, error) {
//				panic("mock out the ProgramExists method")
//			},
//			SetOwnershipFunc: func(path string, username string) error {
//				panic("mock out the SetOwnership method")
//			},
//			SetPermissionsFunc: func(path string, mode os.FileMode) error {
//				panic("mock out the SetPermissions method")
//			},
//			UserExistsFunc: func(username string) (bool, error) {
//				panic("mock out the UserExists method")
//			},
//		}
//
//		// use mockedOsManager in code that requires OsManager
//		// and then make assertions.
//
//	}
type MoqOsManager struct {
	// AddSudoAccessFunc mocks the AddSudoAccess method.
	AddSudoAccessFunc func(username string) error

	// AddUserFunc mocks the AddUser method.
	AddUserFunc func(username string) error

	// AddUserToGroupFunc mocks the AddUserToGroup method.
	AddUserToGroupFunc func(username string, group string) error

	// GetFileOwnerFunc mocks the GetFileOwner method.
	GetFileOwnerFunc func(path string) (string, error)

	// GetProgramPathFunc mocks the GetProgramPath method.
	GetProgramPathFunc func(program string) (string, error)

	// GetProgramVersionFunc mocks the GetProgramVersion method.
	GetProgramVersionFunc func(program string, versionExtractor VersionExtractor, queryArgs ...string) (string, error)

	// ProgramExistsFunc mocks the ProgramExists method.
	ProgramExistsFunc func(program string) (bool, error)

	// SetOwnershipFunc mocks the SetOwnership method.
	SetOwnershipFunc func(path string, username string) error

	// SetPermissionsFunc mocks the SetPermissions method.
	SetPermissionsFunc func(path string, mode os.FileMode) error

	// UserExistsFunc mocks the UserExists method.
	UserExistsFunc func(username string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddSudoAccess holds details about calls to the AddSudoAccess method.
		AddSudoAccess []struct {
			// Username is the username argument value.
			Username string
		}
		// AddUser holds details about calls to the AddUser method.
		AddUser []struct {
			// Username is the username argument value.
			Username string
		}
		// AddUserToGroup holds details about calls to the AddUserToGroup method.
		AddUserToGroup []struct {
			// Username is the username argument value.
			Username string
			// Group is the group argument value.
			Group string
		}
		// GetFileOwner holds details about calls to the GetFileOwner method.
		GetFileOwner []struct {
			// Path is the path argument value.
			Path string
		}
		// GetProgramPath holds details about calls to the GetProgramPath method.
		GetProgramPath []struct {
			// Program is the program argument value.
			Program string
		}
		// GetProgramVersion holds details about calls to the GetProgramVersion method.
		GetProgramVersion []struct {
			// Program is the program argument value.
			Program string
			// VersionExtractor is the versionExtractor argument value.
			VersionExtractor VersionExtractor
			// QueryArgs is the queryArgs argument value.
			QueryArgs []string
		}
		// ProgramExists holds details about calls to the ProgramExists method.
		ProgramExists []struct {
			// Program is the program argument value.
			Program string
		}
		// SetOwnership holds details about calls to the SetOwnership method.
		SetOwnership []struct {
			// Path is the path argument value.
			Path string
			// Username is the username argument value.
			Username string
		}
		// SetPermissions holds details about calls to the SetPermissions method.
		SetPermissions []struct {
			// Path is the path argument value.
			Path string
			// Mode is the mode argument value.
			Mode os.FileMode
		}
		// UserExists holds details about calls to the UserExists method.
		UserExists []struct {
			// Username is the username argument value.
			Username string
		}
	}
	lockAddSudoAccess     sync.RWMutex
	lockAddUser           sync.RWMutex
	lockAddUserToGroup    sync.RWMutex
	lockGetFileOwner      sync.RWMutex
	lockGetProgramPath    sync.RWMutex
	lockGetProgramVersion sync.RWMutex
	lockProgramExists     sync.RWMutex
	lockSetOwnership      sync.RWMutex
	lockSetPermissions    sync.RWMutex
	lockUserExists        sync.RWMutex
}

// AddSudoAccess calls AddSudoAccessFunc.
func (mock *MoqOsManager) AddSudoAccess(username string) error {
	if mock.AddSudoAccessFunc == nil {
		panic("MoqOsManager.AddSudoAccessFunc: method is nil but OsManager.AddSudoAccess was just called")
	}
	callInfo := struct {
		Username string
	}{
		Username: username,
	}
	mock.lockAddSudoAccess.Lock()
	mock.calls.AddSudoAccess = append(mock.calls.AddSudoAccess, callInfo)
	mock.lockAddSudoAccess.Unlock()
	return mock.AddSudoAccessFunc(username)
}

// AddSudoAccessCalls gets all the calls that were made to AddSudoAccess.
// Check the length with:
//
//	len(mockedOsManager.AddSudoAccessCalls())
func (mock *MoqOsManager) AddSudoAccessCalls() []struct {
	Username string
} {
	var calls []struct {
		Username string
	}
	mock.lockAddSudoAccess.RLock()
	calls = mock.calls.AddSudoAccess
	mock.lockAddSudoAccess.RUnlock()
	return calls
}

// AddUser calls AddUserFunc.
func (mock *MoqOsManager) AddUser(username string) error {
	if mock.AddUserFunc == nil {
		panic("MoqOsManager.AddUserFunc: method is nil but OsManager.AddUser was just called")
	}
	callInfo := struct {
		Username string
	}{
		Username: username,
	}
	mock.lockAddUser.Lock()
	mock.calls.AddUser = append(mock.calls.AddUser, callInfo)
	mock.lockAddUser.Unlock()
	return mock.AddUserFunc(username)
}

// AddUserCalls gets all the calls that were made to AddUser.
// Check the length with:
//
//	len(mockedOsManager.AddUserCalls())
func (mock *MoqOsManager) AddUserCalls() []struct {
	Username string
} {
	var calls []struct {
		Username string
	}
	mock.lockAddUser.RLock()
	calls = mock.calls.AddUser
	mock.lockAddUser.RUnlock()
	return calls
}

// AddUserToGroup calls AddUserToGroupFunc.
func (mock *MoqOsManager) AddUserToGroup(username string, group string) error {
	if mock.AddUserToGroupFunc == nil {
		panic("MoqOsManager.AddUserToGroupFunc: method is nil but OsManager.AddUserToGroup was just called")
	}
	callInfo := struct {
		Username string
		Group    string
	}{
		Username: username,
		Group:    group,
	}
	mock.lockAddUserToGroup.Lock()
	mock.calls.AddUserToGroup = append(mock.calls.AddUserToGroup, callInfo)
	mock.lockAddUserToGroup.Unlock()
	return mock.AddUserToGroupFunc(username, group)
}

// AddUserToGroupCalls gets all the calls that were made to AddUserToGroup.
// Check the length with:
//
//	len(mockedOsManager.AddUserToGroupCalls())
func (mock *MoqOsManager) AddUserToGroupCalls() []struct {
	Username string
	Group    string
} {
	var calls []struct {
		Username string
		Group    string
	}
	mock.lockAddUserToGroup.RLock()
	calls = mock.calls.AddUserToGroup
	mock.lockAddUserToGroup.RUnlock()
	return calls
}

// GetFileOwner calls GetFileOwnerFunc.
func (mock *MoqOsManager) GetFileOwner(path string) (string, error) {
	if mock.GetFileOwnerFunc == nil {
		panic("MoqOsManager.GetFileOwnerFunc: method is nil but OsManager.GetFileOwner was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGetFileOwner.Lock()
	mock.calls.GetFileOwner = append(mock.calls.GetFileOwner, callInfo)
	mock.lockGetFileOwner.Unlock()
	return mock.GetFileOwnerFunc(path)
}

// GetFileOwnerCalls gets all the calls that were made to GetFileOwner.
// Check the length with:
//
//	len(mockedOsManager.GetFileOwnerCalls())
func (mock *MoqOsManager) GetFileOwnerCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGetFileOwner.RLock()
	calls = mock.calls.GetFileOwner
	mock.lockGetFileOwner.RUnlock()
	return calls
}

// GetProgramPath calls GetProgramPathFunc.
func (mock *MoqOsManager) GetProgramPath(program string) (string, error) {
	if mock.GetProgramPathFunc == nil {
		panic("MoqOsManager.GetProgramPathFunc: method is nil but OsManager.GetProgramPath was just called")
	}
	callInfo := struct {
		Program string
	}{
		Program: program,
	}
	mock.lockGetProgramPath.Lock()
	mock.calls.GetProgramPath = append(mock.calls.GetProgramPath, callInfo)
	mock.lockGetProgramPath.Unlock()
	return mock.GetProgramPathFunc(program)
}

// GetProgramPathCalls gets all the calls that were made to GetProgramPath.
// Check the length with:
//
//	len(mockedOsManager.GetProgramPathCalls())
func (mock *MoqOsManager) GetProgramPathCalls() []struct {
	Program string
} {
	var calls []struct {
		Program string
	}
	mock.lockGetProgramPath.RLock()
	calls = mock.calls.GetProgramPath
	mock.lockGetProgramPath.RUnlock()
	return calls
}

// GetProgramVersion calls GetProgramVersionFunc.
func (mock *MoqOsManager) GetProgramVersion(program string, versionExtractor VersionExtractor, queryArgs ...string) (string, error) {
	if mock.GetProgramVersionFunc == nil {
		panic("MoqOsManager.GetProgramVersionFunc: method is nil but OsManager.GetProgramVersion was just called")
	}
	callInfo := struct {
		Program          string
		VersionExtractor VersionExtractor
		QueryArgs        []string
	}{
		Program:          program,
		VersionExtractor: versionExtractor,
		QueryArgs:        queryArgs,
	}
	mock.lockGetProgramVersion.Lock()
	mock.calls.GetProgramVersion = append(mock.calls.GetProgramVersion, callInfo)
	mock.lockGetProgramVersion.Unlock()
	return mock.GetProgramVersionFunc(program, versionExtractor, queryArgs...)
}

// GetProgramVersionCalls gets all the calls that were made to GetProgramVersion.
// Check the length with:
//
//	len(mockedOsManager.GetProgramVersionCalls())
func (mock *MoqOsManager) GetProgramVersionCalls() []struct {
	Program          string
	VersionExtractor VersionExtractor
	QueryArgs        []string
} {
	var calls []struct {
		Program          string
		VersionExtractor VersionExtractor
		QueryArgs        []string
	}
	mock.lockGetProgramVersion.RLock()
	calls = mock.calls.GetProgramVersion
	mock.lockGetProgramVersion.RUnlock()
	return calls
}

// ProgramExists calls ProgramExistsFunc.
func (mock *MoqOsManager) ProgramExists(program string) (bool, error) {
	if mock.ProgramExistsFunc == nil {
		panic("MoqOsManager.ProgramExistsFunc: method is nil but OsManager.ProgramExists was just called")
	}
	callInfo := struct {
		Program string
	}{
		Program: program,
	}
	mock.lockProgramExists.Lock()
	mock.calls.ProgramExists = append(mock.calls.ProgramExists, callInfo)
	mock.lockProgramExists.Unlock()
	return mock.ProgramExistsFunc(program)
}

// ProgramExistsCalls gets all the calls that were made to ProgramExists.
// Check the length with:
//
//	len(mockedOsManager.ProgramExistsCalls())
func (mock *MoqOsManager) ProgramExistsCalls() []struct {
	Program string
} {
	var calls []struct {
		Program string
	}
	mock.lockProgramExists.RLock()
	calls = mock.calls.ProgramExists
	mock.lockProgramExists.RUnlock()
	return calls
}

// SetOwnership calls SetOwnershipFunc.
func (mock *MoqOsManager) SetOwnership(path string, username string) error {
	if mock.SetOwnershipFunc == nil {
		panic("MoqOsManager.SetOwnershipFunc: method is nil but OsManager.SetOwnership was just called")
	}
	callInfo := struct {
		Path     string
		Username string
	}{
		Path:     path,
		Username: username,
	}
	mock.lockSetOwnership.Lock()
	mock.calls.SetOwnership = append(mock.calls.SetOwnership, callInfo)
	mock.lockSetOwnership.Unlock()
	return mock.SetOwnershipFunc(path, username)
}

// SetOwnershipCalls gets all the calls that were made to SetOwnership.
// Check the length with:
//
//	len(mockedOsManager.SetOwnershipCalls())
func (mock *MoqOsManager) SetOwnershipCalls() []struct {
	Path     string
	Username string
} {
	var calls []struct {
		Path     string
		Username string
	}
	mock.lockSetOwnership.RLock()
	calls = mock.calls.SetOwnership
	mock.lockSetOwnership.RUnlock()
	return calls
}

// SetPermissions calls SetPermissionsFunc.
func (mock *MoqOsManager) SetPermissions(path string, mode os.FileMode) error {
	if mock.SetPermissionsFunc == nil {
		panic("MoqOsManager.SetPermissionsFunc: method is nil but OsManager.SetPermissions was just called")
	}
	callInfo := struct {
		Path string
		Mode os.FileMode
	}{
		Path: path,
		Mode: mode,
	}
	mock.lockSetPermissions.Lock()
	mock.calls.SetPermissions = append(mock.calls.SetPermissions, callInfo)
	mock.lockSetPermissions.Unlock()
	return mock.SetPermissionsFunc(path, mode)
}

// SetPermissionsCalls gets all the calls that were made to SetPermissions.
// Check the length with:
//
//	len(mockedOsManager.SetPermissionsCalls())
func (mock *MoqOsManager) SetPermissionsCalls() []struct {
	Path string
	Mode os.FileMode
} {
	var calls []struct {
		Path string
		Mode os.FileMode
	}
	mock.lockSetPermissions.RLock()
	calls = mock.calls.SetPermissions
	mock.lockSetPermissions.RUnlock()
	return calls
}

// UserExists calls UserExistsFunc.
func (mock *MoqOsManager) UserExists(username string) (bool, error) {
	if mock.UserExistsFunc == nil {
		panic("MoqOsManager.UserExistsFunc: method is nil but OsManager.UserExists was just called")
	}
	callInfo := struct {
		Username string
	}{
		Username: username,
	}
	mock.lockUserExists.Lock()
	mock.calls.UserExists = append(mock.calls.UserExists, callInfo)
	mock.lockUserExists.Unlock()
	return mock.UserExistsFunc(username)
}

// UserExistsCalls gets all the calls that were made to UserExists.
// Check the length with:
//
//	len(mockedOsManager.UserExistsCalls())
func (mock *MoqOsManager) UserExistsCalls() []struct {
	Username string
} {
	var calls []struct {
		Username string
	}
	mock.lockUserExists.RLock()
	calls = mock.calls.UserExists
	mock.lockUserExists.RUnlock()
	return calls
}
