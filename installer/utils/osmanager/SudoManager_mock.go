// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package osmanager

import (
	"sync"
)

// Ensure that MoqSudoManager does implement SudoManager.
// If this is not the case, regenerate this file with mockery.
var _ SudoManager = &MoqSudoManager{}

// MoqSudoManager is a mock implementation of SudoManager.
//
//	func TestSomethingThatUsesSudoManager(t *testing.T) {
//
//		// make and configure a mocked SudoManager
//		mockedSudoManager := &MoqSudoManager{
//			AddSudoAccessFunc: func(username string) error {
//				panic("mock out the AddSudoAccess method")
//			},
//		}
//
//		// use mockedSudoManager in code that requires SudoManager
//		// and then make assertions.
//
//	}
type MoqSudoManager struct {
	// AddSudoAccessFunc mocks the AddSudoAccess method.
	AddSudoAccessFunc func(username string) error

	// calls tracks calls to the methods.
	calls struct {
		// AddSudoAccess holds details about calls to the AddSudoAccess method.
		AddSudoAccess []struct {
			// Username is the username argument value.
			Username string
		}
	}
	lockAddSudoAccess sync.RWMutex
}

// AddSudoAccess calls AddSudoAccessFunc.
func (mock *MoqSudoManager) AddSudoAccess(username string) error {
	if mock.AddSudoAccessFunc == nil {
		panic("MoqSudoManager.AddSudoAccessFunc: method is nil but SudoManager.AddSudoAccess was just called")
	}
	callInfo := struct {
		Username string
	}{
		Username: username,
	}
	mock.lockAddSudoAccess.Lock()
	mock.calls.AddSudoAccess = append(mock.calls.AddSudoAccess, callInfo)
	mock.lockAddSudoAccess.Unlock()
	return mock.AddSudoAccessFunc(username)
}

// AddSudoAccessCalls gets all the calls that were made to AddSudoAccess.
// Check the length with:
//
//	len(mockedSudoManager.AddSudoAccessCalls())
func (mock *MoqSudoManager) AddSudoAccessCalls() []struct {
	Username string
} {
	var calls []struct {
		Username string
	}
	mock.lockAddSudoAccess.RLock()
	calls = mock.calls.AddSudoAccess
	mock.lockAddSudoAccess.RUnlock()
	return calls
}
