// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package osmanager

import (
	"sync"
)

// Ensure that MoqUserManager does implement UserManager.
// If this is not the case, regenerate this file with mockery.
var _ UserManager = &MoqUserManager{}

// MoqUserManager is a mock implementation of UserManager.
//
//	func TestSomethingThatUsesUserManager(t *testing.T) {
//
//		// make and configure a mocked UserManager
//		mockedUserManager := &MoqUserManager{
//			AddUserFunc: func(username string) error {
//				panic("mock out the AddUser method")
//			},
//			AddUserToGroupFunc: func(username string, group string) error {
//				panic("mock out the AddUserToGroup method")
//			},
//			GetConfigDirFunc: func() (string, error) {
//				panic("mock out the GetConfigDir method")
//			},
//			GetHomeDirFunc: func() (string, error) {
//				panic("mock out the GetHomeDir method")
//			},
//			UserExistsFunc: func(username string) (bool, error) {
//				panic("mock out the UserExists method")
//			},
//		}
//
//		// use mockedUserManager in code that requires UserManager
//		// and then make assertions.
//
//	}
type MoqUserManager struct {
	// AddUserFunc mocks the AddUser method.
	AddUserFunc func(username string) error

	// AddUserToGroupFunc mocks the AddUserToGroup method.
	AddUserToGroupFunc func(username string, group string) error

	// GetConfigDirFunc mocks the GetConfigDir method.
	GetConfigDirFunc func() (string, error)

	// GetHomeDirFunc mocks the GetHomeDir method.
	GetHomeDirFunc func() (string, error)

	// UserExistsFunc mocks the UserExists method.
	UserExistsFunc func(username string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddUser holds details about calls to the AddUser method.
		AddUser []struct {
			// Username is the username argument value.
			Username string
		}
		// AddUserToGroup holds details about calls to the AddUserToGroup method.
		AddUserToGroup []struct {
			// Username is the username argument value.
			Username string
			// Group is the group argument value.
			Group string
		}
		// GetConfigDir holds details about calls to the GetConfigDir method.
		GetConfigDir []struct {
		}
		// GetHomeDir holds details about calls to the GetHomeDir method.
		GetHomeDir []struct {
		}
		// UserExists holds details about calls to the UserExists method.
		UserExists []struct {
			// Username is the username argument value.
			Username string
		}
	}
	lockAddUser        sync.RWMutex
	lockAddUserToGroup sync.RWMutex
	lockGetConfigDir   sync.RWMutex
	lockGetHomeDir     sync.RWMutex
	lockUserExists     sync.RWMutex
}

// AddUser calls AddUserFunc.
func (mock *MoqUserManager) AddUser(username string) error {
	if mock.AddUserFunc == nil {
		panic("MoqUserManager.AddUserFunc: method is nil but UserManager.AddUser was just called")
	}
	callInfo := struct {
		Username string
	}{
		Username: username,
	}
	mock.lockAddUser.Lock()
	mock.calls.AddUser = append(mock.calls.AddUser, callInfo)
	mock.lockAddUser.Unlock()
	return mock.AddUserFunc(username)
}

// AddUserCalls gets all the calls that were made to AddUser.
// Check the length with:
//
//	len(mockedUserManager.AddUserCalls())
func (mock *MoqUserManager) AddUserCalls() []struct {
	Username string
} {
	var calls []struct {
		Username string
	}
	mock.lockAddUser.RLock()
	calls = mock.calls.AddUser
	mock.lockAddUser.RUnlock()
	return calls
}

// AddUserToGroup calls AddUserToGroupFunc.
func (mock *MoqUserManager) AddUserToGroup(username string, group string) error {
	if mock.AddUserToGroupFunc == nil {
		panic("MoqUserManager.AddUserToGroupFunc: method is nil but UserManager.AddUserToGroup was just called")
	}
	callInfo := struct {
		Username string
		Group    string
	}{
		Username: username,
		Group:    group,
	}
	mock.lockAddUserToGroup.Lock()
	mock.calls.AddUserToGroup = append(mock.calls.AddUserToGroup, callInfo)
	mock.lockAddUserToGroup.Unlock()
	return mock.AddUserToGroupFunc(username, group)
}

// AddUserToGroupCalls gets all the calls that were made to AddUserToGroup.
// Check the length with:
//
//	len(mockedUserManager.AddUserToGroupCalls())
func (mock *MoqUserManager) AddUserToGroupCalls() []struct {
	Username string
	Group    string
} {
	var calls []struct {
		Username string
		Group    string
	}
	mock.lockAddUserToGroup.RLock()
	calls = mock.calls.AddUserToGroup
	mock.lockAddUserToGroup.RUnlock()
	return calls
}

// GetConfigDir calls GetConfigDirFunc.
func (mock *MoqUserManager) GetConfigDir() (string, error) {
	if mock.GetConfigDirFunc == nil {
		panic("MoqUserManager.GetConfigDirFunc: method is nil but UserManager.GetConfigDir was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetConfigDir.Lock()
	mock.calls.GetConfigDir = append(mock.calls.GetConfigDir, callInfo)
	mock.lockGetConfigDir.Unlock()
	return mock.GetConfigDirFunc()
}

// GetConfigDirCalls gets all the calls that were made to GetConfigDir.
// Check the length with:
//
//	len(mockedUserManager.GetConfigDirCalls())
func (mock *MoqUserManager) GetConfigDirCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetConfigDir.RLock()
	calls = mock.calls.GetConfigDir
	mock.lockGetConfigDir.RUnlock()
	return calls
}

// GetHomeDir calls GetHomeDirFunc.
func (mock *MoqUserManager) GetHomeDir() (string, error) {
	if mock.GetHomeDirFunc == nil {
		panic("MoqUserManager.GetHomeDirFunc: method is nil but UserManager.GetHomeDir was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetHomeDir.Lock()
	mock.calls.GetHomeDir = append(mock.calls.GetHomeDir, callInfo)
	mock.lockGetHomeDir.Unlock()
	return mock.GetHomeDirFunc()
}

// GetHomeDirCalls gets all the calls that were made to GetHomeDir.
// Check the length with:
//
//	len(mockedUserManager.GetHomeDirCalls())
func (mock *MoqUserManager) GetHomeDirCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetHomeDir.RLock()
	calls = mock.calls.GetHomeDir
	mock.lockGetHomeDir.RUnlock()
	return calls
}

// UserExists calls UserExistsFunc.
func (mock *MoqUserManager) UserExists(username string) (bool, error) {
	if mock.UserExistsFunc == nil {
		panic("MoqUserManager.UserExistsFunc: method is nil but UserManager.UserExists was just called")
	}
	callInfo := struct {
		Username string
	}{
		Username: username,
	}
	mock.lockUserExists.Lock()
	mock.calls.UserExists = append(mock.calls.UserExists, callInfo)
	mock.lockUserExists.Unlock()
	return mock.UserExistsFunc(username)
}

// UserExistsCalls gets all the calls that were made to UserExists.
// Check the length with:
//
//	len(mockedUserManager.UserExistsCalls())
func (mock *MoqUserManager) UserExistsCalls() []struct {
	Username string
} {
	var calls []struct {
		Username string
	}
	mock.lockUserExists.RLock()
	calls = mock.calls.UserExists
	mock.lockUserExists.RUnlock()
	return calls
}
