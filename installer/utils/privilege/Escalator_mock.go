// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package privilege

import (
	"sync"
)

// Ensure that MoqEscalator does implement Escalator.
// If this is not the case, regenerate this file with mockery.
var _ Escalator = &MoqEscalator{}

// MoqEscalator is a mock implementation of Escalator.
//
//	func TestSomethingThatUsesEscalator(t *testing.T) {
//
//		// make and configure a mocked Escalator
//		mockedEscalator := &MoqEscalator{
//			EscalateCommandFunc: func(baseCmd string, baseArgs []string) (EscalationResult, error) {
//				panic("mock out the EscalateCommand method")
//			},
//			GetAvailableEscalationMethodsFunc: func() ([]EscalationMethod, error) {
//				panic("mock out the GetAvailableEscalationMethods method")
//			},
//			IsRunningAsRootFunc: func() (bool, error) {
//				panic("mock out the IsRunningAsRoot method")
//			},
//		}
//
//		// use mockedEscalator in code that requires Escalator
//		// and then make assertions.
//
//	}
type MoqEscalator struct {
	// EscalateCommandFunc mocks the EscalateCommand method.
	EscalateCommandFunc func(baseCmd string, baseArgs []string) (EscalationResult, error)

	// GetAvailableEscalationMethodsFunc mocks the GetAvailableEscalationMethods method.
	GetAvailableEscalationMethodsFunc func() ([]EscalationMethod, error)

	// IsRunningAsRootFunc mocks the IsRunningAsRoot method.
	IsRunningAsRootFunc func() (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// EscalateCommand holds details about calls to the EscalateCommand method.
		EscalateCommand []struct {
			// BaseCmd is the baseCmd argument value.
			BaseCmd string
			// BaseArgs is the baseArgs argument value.
			BaseArgs []string
		}
		// GetAvailableEscalationMethods holds details about calls to the GetAvailableEscalationMethods method.
		GetAvailableEscalationMethods []struct {
		}
		// IsRunningAsRoot holds details about calls to the IsRunningAsRoot method.
		IsRunningAsRoot []struct {
		}
	}
	lockEscalateCommand               sync.RWMutex
	lockGetAvailableEscalationMethods sync.RWMutex
	lockIsRunningAsRoot               sync.RWMutex
}

// EscalateCommand calls EscalateCommandFunc.
func (mock *MoqEscalator) EscalateCommand(baseCmd string, baseArgs []string) (EscalationResult, error) {
	if mock.EscalateCommandFunc == nil {
		panic("MoqEscalator.EscalateCommandFunc: method is nil but Escalator.EscalateCommand was just called")
	}
	callInfo := struct {
		BaseCmd  string
		BaseArgs []string
	}{
		BaseCmd:  baseCmd,
		BaseArgs: baseArgs,
	}
	mock.lockEscalateCommand.Lock()
	mock.calls.EscalateCommand = append(mock.calls.EscalateCommand, callInfo)
	mock.lockEscalateCommand.Unlock()
	return mock.EscalateCommandFunc(baseCmd, baseArgs)
}

// EscalateCommandCalls gets all the calls that were made to EscalateCommand.
// Check the length with:
//
//	len(mockedEscalator.EscalateCommandCalls())
func (mock *MoqEscalator) EscalateCommandCalls() []struct {
	BaseCmd  string
	BaseArgs []string
} {
	var calls []struct {
		BaseCmd  string
		BaseArgs []string
	}
	mock.lockEscalateCommand.RLock()
	calls = mock.calls.EscalateCommand
	mock.lockEscalateCommand.RUnlock()
	return calls
}

// GetAvailableEscalationMethods calls GetAvailableEscalationMethodsFunc.
func (mock *MoqEscalator) GetAvailableEscalationMethods() ([]EscalationMethod, error) {
	if mock.GetAvailableEscalationMethodsFunc == nil {
		panic("MoqEscalator.GetAvailableEscalationMethodsFunc: method is nil but Escalator.GetAvailableEscalationMethods was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetAvailableEscalationMethods.Lock()
	mock.calls.GetAvailableEscalationMethods = append(mock.calls.GetAvailableEscalationMethods, callInfo)
	mock.lockGetAvailableEscalationMethods.Unlock()
	return mock.GetAvailableEscalationMethodsFunc()
}

// GetAvailableEscalationMethodsCalls gets all the calls that were made to GetAvailableEscalationMethods.
// Check the length with:
//
//	len(mockedEscalator.GetAvailableEscalationMethodsCalls())
func (mock *MoqEscalator) GetAvailableEscalationMethodsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetAvailableEscalationMethods.RLock()
	calls = mock.calls.GetAvailableEscalationMethods
	mock.lockGetAvailableEscalationMethods.RUnlock()
	return calls
}

// IsRunningAsRoot calls IsRunningAsRootFunc.
func (mock *MoqEscalator) IsRunningAsRoot() (bool, error) {
	if mock.IsRunningAsRootFunc == nil {
		panic("MoqEscalator.IsRunningAsRootFunc: method is nil but Escalator.IsRunningAsRoot was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsRunningAsRoot.Lock()
	mock.calls.IsRunningAsRoot = append(mock.calls.IsRunningAsRoot, callInfo)
	mock.lockIsRunningAsRoot.Unlock()
	return mock.IsRunningAsRootFunc()
}

// IsRunningAsRootCalls gets all the calls that were made to IsRunningAsRoot.
// Check the length with:
//
//	len(mockedEscalator.IsRunningAsRootCalls())
func (mock *MoqEscalator) IsRunningAsRootCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsRunningAsRoot.RLock()
	calls = mock.calls.IsRunningAsRoot
	mock.lockIsRunningAsRoot.RUnlock()
	return calls
}
