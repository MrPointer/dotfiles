// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package privilege

import (
	"sync"
)

// Ensure that MoqProgramQuery does implement ProgramQuery.
// If this is not the case, regenerate this file with mockery.
var _ ProgramQuery = &MoqProgramQuery{}

// MoqProgramQuery is a mock implementation of ProgramQuery.
//
//	func TestSomethingThatUsesProgramQuery(t *testing.T) {
//
//		// make and configure a mocked ProgramQuery
//		mockedProgramQuery := &MoqProgramQuery{
//			ProgramExistsFunc: func(program string) (bool, error) {
//				panic("mock out the ProgramExists method")
//			},
//		}
//
//		// use mockedProgramQuery in code that requires ProgramQuery
//		// and then make assertions.
//
//	}
type MoqProgramQuery struct {
	// ProgramExistsFunc mocks the ProgramExists method.
	ProgramExistsFunc func(program string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// ProgramExists holds details about calls to the ProgramExists method.
		ProgramExists []struct {
			// Program is the program argument value.
			Program string
		}
	}
	lockProgramExists sync.RWMutex
}

// ProgramExists calls ProgramExistsFunc.
func (mock *MoqProgramQuery) ProgramExists(program string) (bool, error) {
	if mock.ProgramExistsFunc == nil {
		panic("MoqProgramQuery.ProgramExistsFunc: method is nil but ProgramQuery.ProgramExists was just called")
	}
	callInfo := struct {
		Program string
	}{
		Program: program,
	}
	mock.lockProgramExists.Lock()
	mock.calls.ProgramExists = append(mock.calls.ProgramExists, callInfo)
	mock.lockProgramExists.Unlock()
	return mock.ProgramExistsFunc(program)
}

// ProgramExistsCalls gets all the calls that were made to ProgramExists.
// Check the length with:
//
//	len(mockedProgramQuery.ProgramExistsCalls())
func (mock *MoqProgramQuery) ProgramExistsCalls() []struct {
	Program string
} {
	var calls []struct {
		Program string
	}
	mock.lockProgramExists.RLock()
	calls = mock.calls.ProgramExists
	mock.lockProgramExists.RUnlock()
	return calls
}
